# Разрешение зависимостей

## Разрешение по типу
Основной вид разрешения зависимостей - по типу. Если вы зарегестрировали класс `Cat`, то класс `Cat` будет уникальным ключем, по которому можно получить экземпляр этого класса. К примеру:
```Swift
builder.register(Cat.self).initializer { Cat() }
...
let scope = try! builder.build()
```
Сдесь мы регистрируем класс `Cat`, и создаем scope. После чего мы в любой точки программы можем создать экземпляр данного класса, простым способом:
```Swift
let cat = try! scope.resolve(Cat.self)
```
Мы попросили разрешить зависимость по типу `Cat`, в результате чего получили экземпляр этого класса.

## Разрешение по типу и имени
Немного расширим прошлый пример и предположим, что у в нашей программе "доме" есть всего два кота: Felix и Tiger.
```Swift
builder.register{ Cat() }.asName("Felix").asName("Tiger").instancePerScope()
```
теперь в нашей программе существует два кота, и мы можем их получить следующий образом:
```Swift
let felix = try! scope.resolve(Cat.self, name: "Felix")
let tiger = try! scope.resolve(Cat.self, name: "Tiger")
```
Мы получили двух разных котов, несмотря на то что область видимости у них perScope, но если мы запросим по одному и томуже имени, то и получим мы одного и тогоже кота. Также в данном примере, если мы попробуем разрешить зависимости прошлым способом, то программа кинет исключение, так как кота без имени не существует.
Вы также можете дописать при регистрации: `.asDefault()` и тогда у вас появится еще третий кот "без имени".

## Разрешение зависимостей для множественной регистрации
Но в предыдущем примере, писать `asDefault()` смысла не имеет. Но есть случаи когда это имеет смысл. Например у нас есть класс `Animal`, и от него отнаследованы классы: `Cat`, `Dog`, `Bird`. Зарегестрировать данное выражение можно следующим образом:
```Swift
builder.register{ Cat() }.asSelf().asType(Animal.self)
builder.register{ Dog() }.asSelf().asType(Animal.self)
builder.register{ Bird() }.asSelf().asType(Animal.self)
```

Как видите мы зарегестрировали в системе 3 вида животных: кошки, собаки, птицы, и все они также доступны по имени 'Animals'. То есть мы можем сейчас написать следующий код:
```Swift
let cat = try! scope.resolve(Cat.self)
let dog = try! scope.resolve(Dog.self)
let bird = try! scope.resolve(Bird.self)
let animals = try! scope.resolveMany(Animal.self) // [Cat(), Dog(), Bird()]
```
То есть мы можем получить конкретное животное, или же получить всех животных в системе. В данном примере мы не сможем получил экземпляр 1 животного, так как у нас в системе есть не одназначность. Но добавив `asDefault()` к одному из выражений, мы сможем получить экземпляр 1 животного. К примеру, в коде регистрации мы изменили первую строчку:
```Swift
builder.register{ Cat() }.asSelf().asType(Animal.self).asDefault()
```
Теперь если мы напишем вот так:
```Swift
let animal = try! scope.resolve(Animal.self)
```
То мы получим экземпляр класса Cat().
Более приближенный к реальности пример вы можете посмотреть в главе: [Регистрация с указанием имени/множественная регистрация](multi_name_registration.md)

## Разрешение зависимостей с параметрами
Предположим, что мы хотим создавать кота, и давать ему кличку. В этом случае мы можем написать так:
```Swift
builder.register(Cat.self).initializer { _, name in Cat(name: name) }
...
let felix = scope.resolve(Cat.self, arg: "felix")
let tiger = scope.resolve(Cat.self, arg: "tiger")
```
В данном примере мы создали двух котов, и передали им имена в качестве входного параметра. 
Входных аргументов может быть любое количество (в реальности в системе зарегестирована возможность до 9 входных аргументов), и они могут быть любого типа. То есть это можно рассматривать полностью как эквивалент метода init - конструктора.

## Автоматический вывод типов
Во всех предыдущих примерах, мы указывали тип в скобках, но это делать не обязательно, можно писать и по другому, вот несколько примеров:
```Swift
let cat = try! scope.resolve(Cat.self)
let cat = try! scope.resolve() as Cat
let cat: Cat = try! scope.resolve()
...
var cat: Cat? = nil
cat = try? scope.resolve()
...
var cat: Cat! = nil
cat = try! scope.resolve()
```
Как видим библиотека поддерживает автоматический вывод типов. Более того поддерживается синтаксис для Optional и ImplicitlyUnwrappedOptional типов.

## Проверки во время разрешения зависимостей
Во всех примерах мы писали try! или try?, и также могли писать просто try. Но зачем? К сожалению существуют случаи когда библиотека не может однозначно понять, что от неё хочет программист, или же программист допустил ошибку. В этих случая библиотека бросает исключения, которые бывают следующих видов:

* `DIError.defaultTypeIsNotSpecified(type:,components:)` - не смогла найти "стандартный" в случае множественной регистрации типов. Например в параграфе "Разрешение зависимостей для множественной регистрации" мы не указали нигде `asDefault()` но всеравно написали код: `scope.resolve(Animal.self)` - в этом случае бросится исключение

* `DIError.typeNoRegisterByName` - в системе не зарегестрирован тип с таким именем. Такое исключение возможно если мы пытаем разрешить по типу и имени, но такую пару мы не регестрировали. К примеру если мы в параграфе "Разрешение по типу и имени", напишем следующий код: `scope.resolve(Cat.self, name: "Kitty")` - то бросится исключение

* `DIError.typeIsNotFound(type)` - в системе не заренестрирован указанный тип. Может произойти при любом виде разрешения зависимостей.

* `DIError.typeIsIncorrect(requestedType, realType)` - экземпляр созданного объекта, не соответствуют указанному типу при разрешении зависимостей. Такое возможно только для случаев когда указываются альтернативные типы, так как для них мы не можем статически проверить их корректность.

* `DIError.initializationMethodWithSignatureIsNotFoundFor(type, signature)` - не удалось найти метод инициализации с заданной сигнатурой. Такое возможно если вы зарегестрировали у типа несколько (или один) `initializer`, но при разрешении зависимостей, вы передали сигнатуру которой он не знает. К примеру в параграфе "Разрешение зависимостей с параметрами", можно написать: `scope.resolve(Cat.self, 10)` - программа кинет исключение, так как сигнатуры у функций разные: одна принимает на вход String, а другая Int.

## Сокращенный синтаксис
В предыдущих примерах, мы могли и не писать название методов, а написать проще:
```Swift
let cat: Cat = *!scope // try! scope.resolve()
let cat: Cat? = *?scope // try? scope.resolve()
let cat: Cat = try! *scope  // scope.resolve()
let animals: [Animal] = **!scope  // try! scope.resolveMany()
let animals: [Animal] = try! **scope // scope.resolveMany()
```
В коментария прописан эквивалентный синтаксис. Для людей которые немного знакомы языком с C\С++, может быть знаком данный синтаксис, так как он напоминает оператор "разыменовывания" слегка адаптированный под нужды библиотеки и возможности swift.