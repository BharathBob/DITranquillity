# Миграция с версии 2.x.x на версию 3.x.x
Перед миграцией взвесте все за и против, так-как изменения достаточно колосальные. При этом новый более лаконичный синтаксис с улучшенными проверками возможно вам и не нужны. Основная особенность этого обновления, что API в дальнейшем не будет претерпивать серьезных изменений, будут добавляться новые возможности, но старые изменяться не будут.

Если приведенные ниже возможности не являются для вас критичными, и проект не планируется развиваться еще очень долго, то не стоит проводить миграцию. Но миграцию стоит провести если вы планируете использовать swift4 и выше, так как версии 2.x.x не будут переходить на 4 версию языка. А вот версия 3.x.x разделена: 3.0.x - для swift3, а 3.x.x для 4, где второй x больше 0.


## Описание изменений
Благодаря этому обновлению стала возможным сделать отрисовку графа зависимостей вашего приложения. На текущий момент весь граф хранится только в памяти, но после перехода на swift4 все силы будут направлены на отдельный проект и добавление функционала, для сохранения и визуализации графа зависимостей.

В силу написанных ниже изменений, стало не удобно использовать регистрацию/получение по имени, но при этом теги стали неоемлимой частью библиотеки. У тегов есть преимущество - сложнее допустить опечатку, но и минус - этот тип в приложении, а значит к этому типу должны иметь доступ в разных местах системы.

### DIComponentBuilder + DIComponent = DIComponent
* Произошло слияние DIComponent и DIComponentBuilder. Теперь для регистрации и для получения объекта используется один и тотже объект. Сделано это в рамках упрощения синтаксиса, а также ускорения работы библиотеки. Но в отличии от других библиотек эти действия не защищены от многопоточности. Одновременная регистрация и получение объекта может послужить причиной падения приложения. Также это слияние дает возможность во время исполнения легко подключать дополнительный код.
* Функция `build` удалена. Но это не значит, что вы оставлены самим себе. Теперь появилась более сильная функция `valid` - она проверяет валидность графа связей. Эта функция может гарантировать отсутствие падений во время исполнения из-за некорректных регистраций. Но так как эта проверка основана на валидации графа, она не может гарантировать, что вызовы функции resolve из вашего кода пройдут успешно.
* Функция `register` стала более простой. теперь не надо писать `type:`. Как и раньше функция на вход принимает или Тип или Метод инициализации.
* `resolve` сильно упрощен - он теперь всегда возвращает тот тип который вы от него требуете. Если типа не будет найдено, то программа упадет. Но не бойтесь - опционалы теперь работают на полную мощность. Не надо больше писать try? или какойто особый синтаксис, все делается автоматически. НО! было принято решение что ImplicitlyUnwrappedOptional не является опционалом - если этого типа нет, то программа также упадет.
* Остался всего один сокращенный синтаксис: `*container` который автоматически делает `resolve`.
* В силу чего появились два вспомагательных метода: `by(tag:on:)` и `many(:)`. Для получения объекта по имени придется как и раньше вызвать функцию `resolve(name:)`

### DIComponentBuilder
* Удалилось разделение указание типа, имени, тега. Теперь это одна функция, которая принимает на вход: тип, тип+имя, тип+тег. Причина: На старом синтаксисе было не понятно, как связываются теги, имена и типы между собой. Теперь это явно очевидно.
* Убрано обязательное условие на использование `check` у оператора `as`. Тем немении я настоятельно рекомендую его использовать.
* `setDefault()` переименован в `default()`
* Убраны методы: `initial`. В этом месте произошло понижение возможностей - теперь можно указать только один метод инициализации, и он указывается при вызове функции `register`. Это позволило сократить избыточность синтаксиса, и сделать его более кратким, правда в обмен на одну мало нужную возможность.
* Убрана возможность передачи runtime аргументов. Эта возможность мало используемая, но при этом очень не продуманная: например мне нужно передать аргументы через 3 инициализации в DI, что становится невозможным. Проблема с мульти инициализацией и передачи аргументов будет решена в дальнейшем не стандартным решением.
* Убраны все `.manual` и `.optional` методы. Для построения графа эти методы неприемлимы, поэтому они были убраны. Все для чего раньше надо было применять метод с `.manual` теперь можно решить штатными средствами. Единственное исключение - инициализации которым нужны именованные параметры.
* У функии `injection` для внедрения зависимости по параметру, появился булев флаг: `injection(cycle:)`. Старая реализация позволяющая работать с циклами имела ряд недостатков, которые были устранены в новой версии. Но при этом стало необходимо явно указывать места где возможны циклы. В принципе функция `valid()` не пройдет если будут циклы которые невозможно создать, и напишет ошибку в логи - какие именно циклы надо "разорвать". Разрыв цикла - это указание у этой функции `true`, то есть: `injection(cycle: true) { $0.property = $1 }`. Как видно библиотека способна сама находить места где стоит поставить данное значение, но не делает это в угоду скорости работы. 


### DIComponent/DIModule -> DIPart/DIFramework 
* `DIComponent` переименован в `DIPart`. Так как компонент является именем используемым в других DI для обозначения другой сущности. Более того новое название лучше отображает его предназначение - это объединение компонентов в одну сущность, то есть это какая-то "часть" системы.
* `DIModule` переименова в `DIFramework`. Библиотека написана для apple систем, не стоит отклоняться от ихнего способа именования.
* Синтаксис объявления `DIFramework` перестал отличаться от `DIPart`. То есть это два протокола отличающихся лишь название и предназночением.
* `DIFramework` и `DIPart` теперь имеют статическую функцию `load(container:)`. Соответственно регистрируются теперь не экземпляры этих классов, а сами классы.
* Функция `register` разделена. Теперь через эту функции возможно зарегестрировать только новый тип. Чтобы добавить в контейнер `DIFramework` или `DIPart` появились две функции: `append(part:)` и `append(framework:)`
* Полностью удалена область видимости у `DIPart`. Библиотека теперь сама ищет нужный компонет. При поиске учитывается начилие `default` у компоненты и ее иеархичное разменение в bundle.
* Для задания иеархии между frameworks появилась функция `import`. Эта функция действует по аналогии дерективы swift import - она лишь говорит где можно искать реализации. Использовать эту функцию стоит только внутри реализации `DIFramework`, в противном случае библиотека не гарантирует валидность. 

### DIError/DILog
* Полностью убраны ошибки. Теперь все ошибки/предупреждения и информация попадают в логи.
* Логгер стал важной частью системы - если чтото работает не как планировалось, в первую очередь стоит заглянуть в логгер особенно на ошибки с уровнем error и warning.
* Логгирование стало иеархическим. То есть в логах появилась табуляция, которую при желании можно отключить.
* Убран протокол для логирования. Теперь для этих целей можно задать функцию.
* Изменены уровни логирования на: `error`, `warning`, `info`, `none`. И стало возможность фильтровать логи по уровню.

### DIStoryboard
* Убраны отдельные функции для регистрации ViewController - теперь они регистрируются также как и обычные типы
* Создание `DIStoryboard` теперь происходит с помощью статической функции `create(name:bundle:)` или `create(name:bundle:container:)`
* Но стоит регистрировать storyboard отдельной функцией: `registerStoryboard(name:bundle:)` - это упрощает дальнейшую работу и!
* Появилась поддержка storyboardReference. Но сторибоарды на которые ведут ссылки обязаны быть зарегестрированы с помощью функции `registerStoryboard(name:bundle:)`

### DIScan
Так как `DIFramework` и `DIPart` теперь являются классами которые не надо инициализировать, то из-за этого был переработан синтаксис сканирования:
* Теперь для этого придется создавать целый класс. Безусловно синтаксически это стало менее красиво, но зато быстрее с точки зрения исполнения.
* Внутри класса можно переопределить predicate или bundle. При этом для `DIScanFramework` bundle указать нельзя, в силу его ненужности.
* Предикаты также как и раньше остались двух видов: по имени и по типу. При этом если его не переопределить или сделать nil, то будут выданы все фреймворки/части.
* `DIScanned` остался без изменений и несет тотже смысл.
* Если в вашем коде возможна динамическая подрузка кода во время исполнения, то вам может понадобится функция: `DIScan.resetCache()`. Для ускорения работы сканирования все классы единожды кэшируются, и не происходит сканирование всего проекта. Так как код появляется позже, и кэш скорей всего уже создан, то его надо удалить чтобы при следующем обращение он создался заново.

### DILifeTime
* Убран perScope в силу его ненужности.
* `perDependency` разделен на два: `prototype` и `objectGraph`.
* `prototype` - не зависимо ни от чего объект будет создаваться всегда новый.
* `objectGraph` - объект также всегда создается новый, но единожды в рамках одного разрешения зависимостей. Это время жизни стоит указывать в случае циклов, на те объект с которых будет начинаться цикл. В случае если у вас есть цикл состоящий из объектов с разными временами жизни, и есть хотябы один объект с `objectGraph`, то будет написано всеголишь предупреждение, что возможны проблемы.

## Примеры изменений синтаксиса

