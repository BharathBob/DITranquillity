# Время жизни

Любой объект имеет время жизни. Для упрощения работы с объектами был создан ARC, но даже его наличие не покрывает все нужды. Так бывают случаи, когда объект может понадобиться в любое время, но при этом большую часть времени он никому не нужен. В принципе такие объекты являются одним из паттернов программирования и называются "одиночки".

В библиотеке время жизни объявляется у компонентов с помощью метода `lifetime`, который принимает один из возможных вариантов перечисления: `.single`, `.lazySingle`, `.perScope`, `.perDependency`

## Одиночки (single)
Если объект в программе существует на протяжении всего жизненного цикла программы, то такой объект называется "одиночкой". На самом деле в случае с библиотекой объект существует с момента создания контейнера и до завершения программы. Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, надо объявить его как `.single`:
```Swift
builder.register{ Cat() }.lifetime(.single)
```

## Отложенные одиночки (lazySingle)
Если объект в программе существует на протяжении всего жизненного цикла программы, но при этом создается он при первом обращении, то такой объект называется "отложенной одиночкой". Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, но при этом он будет создан при первом обращении, надо объявить его как `.lazySingle`:
```Swift
builder.register{ Cat() }.lifetime(.lazySingle)
```

## Область видимости (perScope)
Scope - это такой же объект, как и контейнер. В принципе для библиотеки верно утверждение - scope и container это одно и то же. Также как у программы могут быть объекты, которые существуют в единственном экземпляре, также и у каждого scope могут быть объекты которые уникальные и единственны для него. То есть если написать:
```Swift
builder.register{ Cat() }.lifetime(.perScope)
```
то кошка будет единственна, для каждого scope. Если scope в программе 1, то это время жизни будет эквивалентно `lazySingleton`.

Чтобы создать новый scope, можно зарегистрировать другие компоненты и создать новый контейнер или же можно для уже существующий компонентов создать копию существующего scope:
```Swift
let newscope = scope.newLifeTimeScope()
```
после чего в новом scope будут доступны все те же самые компоненты, но при этом время жизни у них может различаться:
```Swift
let cat1: Cat = try! scope.resolve()
let equalsCat1: Cat = try! scope.resolve()
let newscope = scope.newLifeTimeScope()
let cat2: Cat = try! newscope.resolve()
let equalsCat2: Cat = try! newscope.resolve()
assert(cat1 === equalsCat1)
assert(cat2 === equalsCat2)
assert(cat1 !== cat2)
```

## Всегда новый (perDependency)
Самое простое в понимании время жизни - каждый раз при запросе у контейнера объекта, создается новый экземпляр. Объявляется он аналогичным образом:
```Swift
builder.register{ Cat() }.lifetime(.perDependency)
```

## По умолчанию (default)
Если у компоненты не указано время жизни, то используется `perScope`.


#### [Главная](main.md)
#### [Предыдущая глава "Указанием имени/множественная регистрация"](multi_name_registration.md)
#### [Следующая глава "Модули"](module.md)