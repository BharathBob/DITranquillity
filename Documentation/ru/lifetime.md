# Время жизни

Любой объект имеет время жизни. Для упрощения работы с объектами был создан ARC, но даже его наличие не покрывает все нужды. Так бывают случаи, когда объект может понадобиться в любое время, но при этом большую часть времени он никому не нужен. В принципе такие объекты являются одним из паттернов программирования и называются "одиночки".

В библиотеке время жизни объявляется у компонентов с помощью метода `lifetime`, который принимает один из возможных вариантов перечисления: `.single`, `.lazySingle`, `.perScope`, `.perDependency`, `.perRequest`

## Одиночки (single)
Если объект в программе существует на протяжении всего жизненного цикла программы, то такой объект называется "одиночкой". На самом деле в случае с библиотекой объект существует с момента создания контейнера и до завершения программы. Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, надо объявить его как `.single`:
```Swift
builder.register{ Cat() }.lifetime(.single)
```

## Отложенные одиночки (lazySingle)
Если объект в программе существует на протяжении всего жизненного цикла программы, но при этом создается он при первом обращении, то такой объект называется "отложенной одиночкой". Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, но при этом он будет создан при первом обращении, надо объявить его как `.lazySingle`:
```Swift
builder.register{ Cat() }.lifetime(.lazySingle)
```

## Область видимости (perScope)
Scope - это такой же объект, как и контейнер. В принципе для библиотеки верно утверждение - scope и container это одно и то же. Также как у программы могут быть объекты, которые существуют в единственном экземпляре, также и у каждого scope могут быть объекты которые уникальные и единственны для него. То есть если написать:
```Swift
builder.register{ Cat() }.lifetime(.perScope)
```
то кошка будет единственна, для каждого scope. Если scope в программе 1, то это время жизни будет эквивалентно `lazySingleton`.

Чтобы создать новый scope, можно зарегистрировать другие компоненты и создать новый контейнер или же можно для уже существующий компонентов создать копию существующего scope:
```Swift
let newscope = scope.newLifeTimeScope()
```
после чего в новом scope будут доступны все те же самые компоненты, но при этом время жизни у них может различаться:
```Swift
let cat1: Cat = try! scope.resolve()
let equalsCat1: Cat = try! scope.resolve()
let newscope = scope.newLifeTimeScope()
let cat2: Cat = try! newscope.resolve()
let equalsCat2: Cat = try! newscope.resolve()
assert(cat1 === equalsCat1)
assert(cat2 === equalsCat2)
assert(cat1 !== cat2)
```

## Всегда новый (perDependency)
Самое простое в понимании время жизни - каждый раз при запросе у контейнера объекта, создается новый экземпляр. Объявляется он аналогичным образом:
```Swift
builder.register{ Cat() }.lifetime(.perDependency)
```

## За создание отвечает кто-то другой (perRequest)
В одной из предыдущих глав [Разрешение зависимостей](resolve.md) упоминалось, что есть возможность встраивать зависимости в уже созданный объект. Если мы заранее знаем, что объект точно не будет создавать библиотека, а это всегда будет делать кто-то другой, то это означает:
* Компонент для этого типа не имеет инициализаторов
* Библиотека точно не следит за временем жизни этого объекта

Чтобы объявить такой случай, у компонента нужно указать время жизни `.perRequest`:
```Swift
builder.register(Cat.self).lifetime(.perRequest)
```

Заметем также, что не был указан метод инициализации. Теперь для создания объекта нужно:
* Инициализировать его
* Внедрить в него зависимости

Данный вид времени жизни не был бы столь популярен, но в стандартном интерфейсе есть storyboard, который создает viewcontroller-ы без участия библиотеки. По этим причинам, если viewcontroller-ы создаются с помощью storyboard их стоит регистрировать с временем жизни `perRequest`

## По умолчанию (default)
Если у компоненты не указано время жизни, то используется `perScope`.


#### [Главная](main.md)
#### [Предыдущая глава "Указанием имени/множественная регистрация"](multi_name_registration.md)
#### [Следующая глава "Модули"](module.md)