# Создание контейнера

После регистрации всех компонентов в `DIContainerBuilder`, или просто билдере, библиотека должна проверить, что не нарушены правила регистрации компонентов. После чего она оптимизирует данные для дальнейшего использования, и выдает на выходе контейнер, с которым будет дальнейшая работа.

Основная цель создания контейнера - отсечь все возможные ошибки как можно раньше. 

## Синтаксис
Чтобы создать контейнер, достаточно у билдера, вызвать метод `build`:
```Swift
let container = try! builder.build()
```

## Процесс создания

Так как во время создания проверяется не нарушены ли правила регистрации и нет ли конфликтов в зависимостях. Поэтому метод `build` может кинуть исключение. Для удобства пользования все возникшие ошибки объединяются в одно исключение содержащее все обнаруженные ошибки.
Настоятельно рекомендую не игнорировать эти исключения, и ранять программу в случае возникновения ошибок, но библиотека не заставляет это делать обязательно, возможно в случае ошибки приложение будет выполнять какие-нибудь специфические действия.


## Проверки и исключения
Все возникшие ошибки объединяются в: `DIError.build(errors: [DIError])`. Далее по тексту будет идти речь об ошибках, которые попадают в список errors.

! Во время чтения этой главы, будет описан синтаксис не встречающийся на текущий момент в документации, поэтому рекомендую вернуться еще раз к этой главе позже.

Во время создания контейнера, библиотека проверяет:
* Нет совпадений имен для одного и того же типа.
> Ошибка: **`DIError.intersectionNamesForType(type:, names:, components:)`**
> Параметры: type - тип, для которого пересекаются имена
?            names - множество имен, которые пересекаются
>            components - все компоненты для этого типа
> Пример:
> ```Swift
> builder.register(Cat.self).asName("Felix")...
> builder.register(Cat.self).asName("Felix")...
> ```
> В данном примере, регистрируются две кошки, с одним и темже именем.
***

* При множественной регистрации указано не более одного default:
> Ошибка: **`DIError.pluralSpecifiedDefaultType(type:, components:)`**
> Параметры: type - тип, для которого указано несколько компонентов
>            components - все компоненты для этого типа 
> Пример:
> ```Swift
> builder.register(Cat.self).asDefault()...
> builder.register(Cat.self).asDefault()...
> ```
> В данном примере, регистрируются две кошки, и обе объявлены по умолчанию.
***

* У типа есть хотябы один метод инициализации, или данный тип отмечат как `perRequest`
> Ошибка: **`DIError.notSpecifiedInitializationMethodFor(component:)`**
> Параметры: component - компонент, в котором был упущен метод инициализации
> Пример:
> ```Swift
> builder.register(Cat.self)
> try! builder.build()
> ```
> В данном примере, мы зарегестрировали кошку, но не указали каким метод её создавать. Такой компонент не имеет смысла так как в дальнейшем не получиться создать объявленный тип.
***


#### Примечания
##### 
component - это специальный тип DIComponent, который содержит более точную информацию, нежели тип. 
В компоненте содержится:
* type - тип, по которому регистрировалась компонента
* file - файл, в котором регистрировалась компонента
* line - строчка кода, на которой регистрировалась компонента
Таким образом, можно легко найти в каком месте была произведена ошибка - или при регистрации, или в момент возникновения ошибки.

#####
```Swift
builder.register(Cat.self).asType(Birds.self)...
``` 
Данный пример содержит ошибку: кот не является птицей, но не смотря на это библиотека пропустит такой код на стадии компиляции и на стадии сборки контейнера.
Ошибка обнаружиться только в тот момент когда программа запросит у библиотеки тип `Birds` - будет произведена проверка, что кошка не является котом, и кинется исключение: 

Ошибка: **`DIError.typeIsIncorrect(requestedType:, realType:, component:)`**
Параметры: requestedType - запрашиваемый тип
           realType - тип объекта, который был создан
           component - компонент, используемый для создания типа

На текущий момент swift не имеет возможностей проверить связь между двумя типами.