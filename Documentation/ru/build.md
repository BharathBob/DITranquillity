# Создание контейнера

## Зачем?
К сожалению какбы не хотелось не все ошибки можно выявить во время компиляции. Более того не все ошибки можно выявить при регистрации. Именно по этому есть понятие "Создание". Она нужна, чтобы проверить конфликты, и уменьшить количество ошибок в будущем. Также она подгатавливает данные в более приемлиемом виде для того чтобы в дальнейшем разрешение зависимостей происходило быстрее.

## Процесс создания
Во время создания, программа просматривает все зарегестированные зависимости, и ищет конфликты. Если были обнаружены какие либо ошибки, то информация о них накапливается, и после выдается пользователю в виде исключения. При этом если во время создания была ошибка, то создание не завершится.
Для начала сборки надо написать следующий код: `builder.build()`
Как было описано выше создание контейнера может кидать исключения, поэтому эти исключения надо поймать.
Я рекомендую использовать простой синтаксис: `try! builder.build()`, так как он сразуже уронит программу в случае если при регистрации произошли ошибки. Возможно в некоторых случаях вы захотите делать другие действия, но это выходит за рамки данной документации.

## Проверки во время создания
Во время создания проверяются следующие вещи:
* Нету совпадений имен для одного и тогоже типа. К примеру код:
> ```Swift
> builder.register(Cat).asName("Felix")...
> builder.register(Cat).asName("Felix")...
> try! builder.build()
> ```
> Кинет исключение: **`DIError.MultyRegisterNamesForType(names:, forType:)`**  
***

* Для нескольких регистраций одного и тогоже типа (включая синтаксис использования альтернативных типов), указан не больше одного default-ого. К примеру код:
> ```Swift
> builder.register(Cat).asDefault()...
> builder.register(Cat).asDefault()...
> try! builder.build()
> ```
> Кинет исключение: **`DIError.MultyRegisterDefault(typeNames:, forType:)`**
***

* Для нескольких регистраций одного и тогоже типа (включая синтаксис использования альтернативных типов), указан хотябы один default или они имеют разные имена. К примеру код:
> ```Swift
> builder.register(Cat)...
> builder.register(Cat)...
> try! builder.build()
> ```
> Кинет исключение: **`DIError.NotSetDefaultForMultyRegisterType(typeNames:,forType:)`**

* При этом надо понимать, что если мы регестрируем один и тотже тип, не указав default-ный, но при этом указав разные имена, то при создании исключений не будет, но разрешать зависимости надо тогда обязательно по имени. К примеру код:
> ```Swift
> builder.register(Cat).asName("Felix")...
> builder.register(Cat).asName("Bella")...
> builder.build()
> ...
> try! scope.resolve(Cat)
> ```
> Кинет исключение во время resolve: **`DIError.NotSetDefaultForMultyRegisterType(typeNames:, forType:)`**
***

* У всех зарегестрированных типов есть хотябы 1 инициализатор. Исключением являются типы с областью видимости PerRequest - для таких типов не обязательно должен присутсвовать инициализиров. К примеру код:
> ```Swift
> builder.register(Cat)
> try! builder.build()
> ```  
> Кинет исключение: **`DIError.NotSetInitializer(typeName:)`**
***


## Чего нету
Проверки - что альтернативные типы, находятся в тойже иеархии классов, что и основной тип. К примеру код:
> ```Swift
> builder.register(Cat).asType(Birds)
> ```  
> Во время регистрации и создании, **не кинет исключение**. Данная ошибка обнаружится, во время разрешения зависимостей, при этом кинет исключение: **`DIError.TypeIncorrect(askableType:, realType:)`**


