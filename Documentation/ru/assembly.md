# Assembly (Сборки)
Сборка - еще более высокий уровень, нежели модуль. В отличие от модулей, которые могут внутри включать любой компонент, сборки состоят только из модулей и зависимостей на другие сборки.

Желательно чтобы на каждый под проект создавалась как минимум одна сборка. Не стоит объявлять одну сборку на несколько под проектов.

## Объявление
Для объявления сборки нужно реализовать протокол DIAssembly:
```Swift
class YourAssembly: DIAssembly {
  var publicModules: [DIModule] = [...]
  var internalModules: [DIModule] = [...]
  
  var dependencies: [DIAssembly] = [...]
}
```

У сборки есть три базовых поля и еще одно дополнительное о нем будет написано ниже:
* publicModules - список всех публичных модулей. Отличие публичных модулей от внутренних будет рассмотрено ниже.
* internalModules - список всех внутренних модулей.
* dependencies - список зависимостей на другие сборки.

### Публичный/Внутренний модуль

Чтобы понимать различие между этими понятиями, достаточно запомнить два правила:
* Публичный модуль включается в саму сборку и во все сборки, которые зависят от этой сборки.
* Внутренний модуль включается в саму сборку, но не включается в сборки, которые зависят от этой сборки.

Под включение надо понимать процесс регистрации, то есть внутренние модули включаются, только если они явно указаны при регистрации.

## Регистрация
После того как мы объявили модуль, его нужно зарегистрировать для дальнейшего использования:
```Swift
builder.register(assembly: YourAssembly())
```
При регистрации сборки, регистрируются все указанные модули и все публичные модули других сборок указанных в зависимостях.

## Динамические
Динамические сборки нужны чтобы разворачивать зависимости между проекта. К примеру, есть первый и второй проект. Второму проекту нужны данные из первого проекта, но при этом не хочется завязывать проекты друг на друга, так как они могут быть в последствии удалены или изменены. Для того чтобы изменения были менее фатальны создаются протоколы, но и этого не достаточно. Тогда принимается решение: протоколы для общения между проектами выносим в отдельный проект и включаем зависимость только на него. Тогда оба проекта будут, зависит только от третьего проекта, который содержит только интерфейсы.

Рассмотрим первую половину диаграммы ниже:
![dynamicassembly_example](https://cloud.githubusercontent.com/assets/5517599/19780234/7296d1ec-9cae-11e6-8592-5cabbfc104a2.png)

На ней DataHandler из первого проекта реализует протокол из третьего проекта, а DataProvider использует интерфейс из третьего проекта.

Теперь если по каким-то причинам будет удален DataHandler, то во втором проекте просто не будет реализации протокола, и он сможет сам принять решение что ему делать в этом случае.

Как пример можно привести два проекта: вход и регистрация. С входа мы можем попасть на регистрацию, но в некоторых случаях регистрация может быть и не нужна и более того в целях экономии места на диске её стоит удалить. Тогда можно представить себе следующий интерфейс: если проект регистрации есть то при входе показывается кнопка для перехода на регистрации, а если нет то не показывается.

Теперь посмотрим на вторую часть диаграммы, там есть DynamicAssembly. Динамическая сборка объявляется так:
```Swift
class DynamicAssembly: DIDynamicAssembly { }
```
В неё можно включать модули и зависимости, как и в обычную сборку, но обычно это не требуется.

Также на диаграмме есть на стрелочках надписи: "декларирует" и "зависит". Что это значит в коде:
```Swift
class Assembly1: DIAssembly {
  ...
  var dynamicDeclarations: [DIDynamicDeclaration] = [
    (module: ModuleWithDataHandler(), for: DynamicAssembly())
  ]
}

class Assembly2: DIAssembly {
  ...
  var dependencies: [DIAssembly] = [ DynamicAssembly ]
}
```

При декларации в динамическую сборку включается модуль, который был указан.

То есть объявляется некоторая сборка, а компоненты/модули в неё включаются позже на этапе исполнения.

### Нюансы
* Типы `singleton` и `lazySingleton` единственные для всей программы, а не сборки.
* Для интерфейсов находящихся в проекте с динамической сборкой не стоит при разрешении зависимостей писать `try!`, так как реализация может отсутствовать. Лучше писать: `try?`.


#### [Главная](main.md)
#### [Предыдущая глава "Модули"](module.md)
#### [Следующая глава "Storyboard"](storyboard.md)
