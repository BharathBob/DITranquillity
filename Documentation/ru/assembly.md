# Assembly (Сборки)
## Зачем?
Как и в случае с модулями, в какойто момент и модулей может стать очень много, тогда на помощью приходят сборки. В отличии от модулей, сборка является более сложным типом, и их нельзя создавать в нескольких экземплярах в программе. Также сборки имеют собственный scope, а значит у сборки тоже есть понятие время жизни.

## Создание
Для создания сборки, нам надо отнаследоватся от базового класса DIAssembly, и переопределить метод init. К примеру это можно сделать так:
```Swift
class YourAssembly: DIAssembly {
  required init() {
    super.init()
  }
}
```

## Как использовать
Предыдущий код имеет один минус - он ничего не регестрирует, но сборки нельзя зарегестрировать. Зато сборки могут иметь зависимости от других сборок, и сборки включают в себя модули. То есть мы можем дополнить предыдущий пример, таким кодом:
```Swift
required init() {
  super.init()

  addModules(YourModule1(), YourModule2(),...)
  addDependencies(YourAssembly1.self, YourAssembly2.self)
}
```
В данном примере, мы в нашу сборку добавили, модули, и добавили зависимости от других сборок. 
Что это будет значить?
Это значит что наша сборка, будет знать обо всех типах внутри модулей + обо всех типах которые написаны в других сборках.

## Создание сборки
Также как и с билдерами, сборки можно создавать. Не рекомендую использовать билдеры и сборки внутри одного приложения, но при этом это никто не запрещает делать. К примеру для нашей сборки мы можем написать:
```Swift
let yourAssembly = try! YourAssembly().build()
```

При этом в вашей программе создастся не только ваша сборка, но и создадутся все зависимые сборки, и у каждой будет собственный scope, и собственный набор типов о которых они знаю. 

Для разрешения зависимостей, с помощью сборки, можно обратится к scope, например: `yourAssembly.scope.resolve()`

## Чистка сборки
Так как сборки имеют собственный scope, но при этом являются единственными в программе (на самом деле вы сами можете создать несколько одних и техже сборок, но зачем?), это значит, что иногда былобы не плохо иметь возможность их чистить. Для этого у сборок существует два метода: `reset()` и `resetAll()` первый метод чистить scope только одной сборки, а второй метод чистит scope текущей сборки и всех зависимых.

## Динамические сборки
Иногда, так бывает, что сборка содержит внутри себя данные, которые будут известны только после того как будут созданы другие сборки. К примеру - вы решили вынести набор интерфейсов в отдельную сборку, но реализация этих интерфейсов разнесена по другим сборкам, которые общаются между друг другом по средствам этих интерфейсов. Это удобно, если вы не хотите жестко завязывать сборки друг на друга, а завязать через посредника, тем самым обеспечив возможность легко убирать часть сборок из вашего проекта (но надо понимать, что в этом случае использовать `try!` при разрешении зависимостей, опасно, так как часть зависимостей является опциональными, в этом случае можно использовать `try?`). Для таких случаев придуманы динамические сборки, которые являются обычными сборками с одним лишь дополнением - в них могут добавлятся модули из других сборок. 
Для того чтобы создать динамическую сборку, надо отнаследоваться от класса: `DIDynamicAssembly`, после чего вы можете делать с этой сборкой все тоже самое, что и с обычной. Для того чтобы добавить теперь модуль из другой сборки нужно воспользоватся методом: `addModule(module, Into: Assembly)`, все это вместе может выглядет тяк:
```Swift
class YourDynamicAssembly: DIDynamicAssembly {
  required init() {
    super.init()
    ...
  }
}
...
class YourAssembly: DIAssembly {
  required init() {
    super.init()
    addModule(YourModuleFromCurrentAssembly(), Into: YourDynamicAssembly.self)
  }
}

```

## Нюансы
* Функция `build()` у сборки возвращает идентичные исключения, что и функция `build()` и билдера.
* Типы `Singleton` и `LazySingleton` единственные для всей программы, а не сборки.
* Функции `reset()` и `resetAll()` чистят объекты обозначенные как perScope, при этом не обязательно, что объект будет удален - это только значит, что сборка перестанет его держать, но если в программе этот объект ктото еще держит, он не уничтожится.
* Наилучший подход 1 проект(подпроект) = 1 сборке, при условии что у вас внутри проекта есть подпроекты. При этом модули не торчат за пределы проекта.
