# Поиск

В крупных проектах может насчитываться десятки, а то и сотни фреймворков. И в каждый фреймворк может состоять из сотни частей.
Упоминать все эти зависимости между частями/фреймворками может стать утомительным делом - добавился новый фреймворк или часть, надо не забыть внести ее в контейнер, удалился фреймворк - надо удалить его из контейнера, и т.д.

В подобных случаях намного удобней придумать простое правило, по которому фреймворки и части будут находиться автоматически. К примеру, все фреймворки оканчиваются на фразу "Framework", а все части именуются как "{Name}Part".
Тогда следуя таким правилам именации, добавление фреймворка или части, можно сделать проще.

На самом деле все идеально не будет, так как создание/удаление фреймворка/части, это не только создание/удаление зависимостей на него, но и также иногда изменение логики. Библиотека не может отвечать за логику, но она может упростить взаимодействие с зависимостями.

## Предыстория
Swift в отличие от Obj-C, не поддерживает Runtime, но кое какие возможности из Obj-C работают и на Swift классах.

По причинам ограничения Swift в этой части, не получиться использовать на прямую фреймворки и части чтобы их отыскать, но и добавление этой возможности не несет сложностей: достаточно фреймворк или часть унаследовать от класса `DIScanned`.
P.S. На самом деле я не уверен, что данный нюанс это плохо – в таком случае идет явное указание, что фреймворк или часть могут быть найдены, и не получится случайно включить что-нибудь лишнее.

## Поиск Фреймворков
Чтобы организовать поиск фреймворков, как было описано выше, нужно от наследоваться от `DIScanned`:
```swift
class YourFramework: DIScanned, DIFramework {
...
}
```

После все фреймворки, которые объявлены как `DIScanned` и удовлетворяю некоторому правилу, можно найти с помощью специального класса  `DIScanFramework`:
```swift
private class YourFrameworkScanner: DIScanFramework {
override class var predicate: Predicate? { return .name({ $0.contains("Framework") }) }
}
container.append(framework: YourFrameworkScanner.self)
```
Предыдущий синтаксис в этой части был красивее, но так как фреймворки и части перешли на статический метод, то и тут пришлось писать через статику. В примере выше, был объявлен специальный класс, у которого определен предикат. Предикаты могут иметь следующие значения:
* nil (по умолчанию) - будут найдены все фреймворки в программе, то есть классы от наследованные от `DIScanned` и реализующие протокол `DIFramework`
* По имени - из всех фреймворков в программе будут отобраны те, чье имя удовлетворяет критерию.
* По типу - из всех фреймворков в программе будут отобраны те, чей тип удовлетворяет критерию.

Сканирование по типу, является более сложным, но позволяет избавиться от проблем случайных опечаток. Например, за место того, чтобы называть все фреймворки одинаково, можно их от наследовать от единого своего класса:
```swift
class YourFramework: YourBaseFramework { ... }

private class YourFrameworkScanner: DIScanFramework {
override class var predicate: Predicate? { return .type({ $0 is YourBaseFramework.Type }) }
}
```

## Поиск частей
Поиск частей идентичен поиску фреймворков, поэтому ниже будут приведен эквивалентный кусок кода:
```swift
class YourPart: DIScanned, DIPart { ... }

private class YourPartScanner: DIScanPart {
override class var predicate: Predicate? { return .name({ $0.contains("Part") }) }
}
container.append(part: YourPartScanner.self)
```

Но в отличие от фреймворков у частей можно задать не только предикат по имени/типу но и задать bundle за пределы которого поиск не выйдет:
```swift
private class YourPartScanner: DIScanPart {
override class var bundle: Bundle? { return Bundle(for: YourPartScanner.self) }
}
container.append(part: YourPartScanner.self)
```
В данном примере был упущен предикат - то есть он nil, но был написан бандл. Данный код означает, что будут найдены все части от наследованные от протокола `DIScanned` которые находятся внутри бандла.


#### [Главная](main.md)
#### [Предыдущая глава "Storyboard"](storyboard.md#storyboard)
#### [Следующая глава "Логирование"](log.md#Логирование)

