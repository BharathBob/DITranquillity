# Поиск по типу/имени

## Зачем?
Иногда проект состоит из многих модулей, и проектов, и в зависимости от ситуации мы хотим включать эх в сборку или нет. Если мы просто будем перечислять список всех модулей, то скорей всего добавление/убирание модуля/проекта будет выглядить так:
* Добавили/Удалили модуль/проект из сборки
* Добавили/Удалили модуль/проект из списка (а возможно и из нескольких)

Чтобы упростить, себе жизнь, и избавиться от второго шага, можно не указывать явно модули/проекты в виде списка, а придумать некоторое правило, как надо называть такие модули/проекты. В таком случаем мы можем пройти по всем модулям/проектам в системе, и если ихнее название удовлетворяет некоторому правилу, то внести его в сборку.

## Поиск модулей
Из-за того что swift не поддерживает runtime, библиотека не может получить все необходимые данные, но есть всеже небольшой класс задач, на которых Obj-C runtime подходит для Swift. А именно можно найти все классы, и узнать ихний супер класс.

Такие ограничения породили, небольшое неудобство: все модуля которые мы хотим искать автоматически должны быть отнаследованы не от протокола, а от класса. Для этого есть специальный класс DIScanned.

Чтобы включить модули удовлетворяющие некоторому условию мы должны:
* Онаследовать все модуля которые мы хотим искать от DIScanned и протокола DIModule:
```swift
class YourModule: DIScanned, DIModule {
  func load(builder: DIContainerBuilder) {
    ...
  }
}
```
* Зарегестрировать модуль DIScanModule, с условием поиска в билдере:
```swift
builder.register(module: DIScanModule(predicateByName: { $0.contains("Module") }))
```

Помимо регистрации по имени, возможна регистрация по типу:
```swift
builder.register(module: DIScanModule(predicateByType: { $0 == YourModule.self }))
```

## Поиск сборок
Поиск сборки, не сильно отличается, от поиска модулей:
* Нам надо отнаследовать все сборки которые мы хотим искать от DIScanned и протокола DIAssembly
* Зарегестрировать сборку DIScanAssembly, с условием поиска в билдере, также как и с модулями.

## Указание Bundle
Если вам проект разделен на подпроекты, то каждый подпроект имеет свой уникальный bundle, и этим можно воспользоваться, при поиске - можно явно указать в каком bundle надо искать модули или сборки. Сделать это можно используя следующий синтаксис:
```swift
DIScanModule(predicateByName: { $0.contains("Module") }, in: Bundle(/*create*/))
...
DIScanAssembly(predicateByType: { $0 == YourModule.self }, in: Bundle(/*create*/))
```

## Как можно еще
Помимо билдера, мы можем использовать подобный синтаксис и в самой сборке, к примеру вот так:
```swift
class YourMainAssembly: DIAssembly {
  public var publicModules: [DIModule] = [DIScanModule(predicateByName: { $0.contains("PublicModule") })]
  public var internalModules: [DIModule] = [DIScanModule(predicateByName: { $0.contains("InternalModule") })]
  public var dependencies: [DIAssembly] = [DIScanAssembly(predicateByName: { $0.contains("Assembly") })]
}
```
