# Поиск

В крупных проекта может насчитываться десятки, а то и сотни подпроектов. И в каждом подпроекте может быть сотни модулей.
Упоминать все эти зависимости может стать утомительным делом - добавился новый модуль, надо его не забыть внести в список модулей, удалился проект - надо удалить на него зависимости, и т.д.

В таких случая намного удобней придумать простое правило, по которому модуля и подпроекты будут искаться автоматически. К примеру, все модули оканчиваются на фразу "Module", а все подроекты именуются как "SubProject".
Тогда следуя таким правилам, добавление подроекта или модуля, будет делаться проще.

На самом деле все идеально не будет, так как создание/удаление модуля/подпроекта, это не только создание/удаление зависимостей на него, но и также изменение логики. Но библиотека не может отвечать за логику, но она может упростить взаимодействие с зависимостями.

## Предыстория
Swift в отличии от Obj-C, не поддерживает Runtime, но кое какие возможности из Obj-C работают и на Swift классах.

По причинам ограничения Swift в этой части, не получиться на прямую использовать модули и сборки чтобы их отыскать, но и добавление этой возможности не несет сложностей: достаточно модуль или сборку унаследовать от класса `DIScanned`. 
P.S. На самом деле я не уверен, что данный нюанс это плохо – в таком случае идет явное указание, что модули или сборки могут быть найдены, и не получится случайно включить что-нибудь лишнее.

## Поиск модулей
Чтобы организовать поиск модулей, как было описано выше вначале нужно модуля унаследовать от `DIScanned`:
```swift
class YourModule: DIScanned, DIModule {
  func load(builder: DIContainerBuilder) {
    ...
  }
}
```


После чего чтобы найти все модули, которые объявлены как `DIScanned` и удовлетворяю указанному правилу, достаточно зарегистрировать специальный модуль `DIScanModule`:
```swift
builder.register(module: DIScanModule(predicateByName: { $0.contains("Module") }))
```

## Поиск сборок
Поиск сборок идентичен процессу поиска модулей. Вначале наследуемся от `DIScanned`:
```swift
class YourAssembly: DIScanned, DIAssembly {
  ...
}
```

После регистрируем сборку: `DIScanAssembly`:
```swift
builder.register(assembly: DIScanAssembly(predicateByName: { $0.contains("Assembly") }))
```

## Указание Bundle
Когда проект слишком большой и состоит из многих подпроектов создавать уникальные правила для каждого подпроекта не удобно. Но на iOS каждый подпроект имеет свой уникальный Bundle, а это значит, что можно организовать поиск модулей внутри заданного подпроекта:
```swift
DIScanModule(predicateByName: { $0.contains("Module") }, in: Bundle(/*create*/))
```

## Возможности
* `DIScanModule` и `DIScanAssembly` поддерживают не только предикат по имени, но и предикат по типу:
```swift
builder.register(module: DIScanModule(predicateByType: { $0() is YourBaseModule() }))
// Тут будут включены в сборку все модуля, которые унаследованы от базового модуля
// Обращаю внимание, что тут создается экземпляр объекта, это возможно из-за того что наследование начинается от DIScanned
```

* Указывать Bundle можно и для DIScanAssembly, но нужно это реже:
```swift
DIScanAssembly(predicateByName: { $0.contains("Assembly") }, in: Bundle(/*create*/))
```
* Так как `DIScanModule` и `DIScanAssembly` сами являются модулем и сборкой то, это позволяет писать так:
```swift
class YourMainAssembly: DIAssembly {
  public var publicModules: [DIModule] = [DIScanModule(predicateByName: { $0.contains("PublicModule") })]
  public var internalModules: [DIModule] = [DIScanModule(predicateByName: { $0.contains("InternalModule") })]
  public var dependencies: [DIAssembly] = [DIScanAssembly(predicateByName: { $0.contains("Assembly") })]
}
```
