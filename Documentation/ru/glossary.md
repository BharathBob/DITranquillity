# Словарик

Данная страница нужна для лучшего понимания слов, которые используются в документации.

* Аргумент - тот же самый аргумент на языке swift который мы передаем в метод инициализации.
* Экземпляр класса - Swift или Obj-C объект, который был создан с помощью библиотеки, используя контейнер.
* [Компонент](registration.md#Регистрация) – набор контрактов с библиотекой, позволяющие описать способ создания объекта.
* [Регистрация](registration.md#Регистрация) - код, записанный в определенном стиле для описания способа создания объекта. При регистрации создаются компоненты.
* [Контейнер](registration.md#Регистрация) - менеджер для  регистрации компонент и создания экземпляров классов.
* [Зависимость](resolve.md#Разрешение-зависимостей) - контракт, между двумя и более объектами, говорящий, что для создания одного объекта требуется создать другие.
* [Внедрение](injection.md#Внедрение) - процесс  - при котором создаются экземпляры классов, описанные как зависимости.
* [Время жизни](lifetime.md#Время-жизни) - время после создания экземпляра класса и до его уничтожения.
* [Часть](part_framework.md#Части-и-Фреймворки) - Класс для объединения нескольких компонентов в одну сущность, для дальнейшего использования.
* [Фреймворк](part_framework.md#Части-и-Фреймворки) -  Класс для объединения нескольких частей в одну сущность, для дальнейшего использования. Имеет возможность указать зависимости между фреймворками.



## Знакомство с идеей "инверсии зависимостей" и "внедрения зависимостей"
Инверсия зависимостей - принцип SOLID, используемый для уменьшения связанности в компьютерных программах.
Смысл его предельно прост:
* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В теории все звучит хорошо, но как дела обстоят на самом деле? Если мы говорим об ООП программах, то в них обязательно присутствует понятие объекта и класса. Если перефразировать все выше сказанное в терминах ООП программы на языке Swift то получим:
* Не стоит внутри одного объекта создавать другие объекты
* Любые объекты должны попадать в объект из вне
* Класс должен знать только о протоколах, и ничего не знать о других классах
* Протокол отвечает на вопрос "что нужно?", а не "что я умею?" - то есть протоколы создаются для того, чтобы класс мог запросить у программы данные, а не чтобы похвастаться программе как он умеет.

Для наглядности приведу пример:
```Swift
class Vehicle {
func move() {
let engine: EngineForVehicle = EngineFabric.new()
position += speed * time
speed += engine.acceleration
}
}
```

```Swift
class Vehicle {
protocol EngineProtocol {
var acceleration: Double
}

let engine: EngineProtocol
init(engine: EngineProtocol) {
self.engine = engine
}
func move() {
position += speed * time
speed += engine.acceleration
}
}
```
В первом случае Vehicle внутри своего метода запрашивает у фабрики конкретный двигатель, который обладает большим количеством свойств, большая часть которых ему не нужны.
Во втором случае Vehicle получает на вход любой двигатель, который имеет лишь те свойства, которые нужны Vehicle и ничего большего.

Но это надуманный пример, слабо относящийся к реальности. Давайте рассмотрим пример части iOS приложения:
Плохо:
```Swift
class ViewController: UIViewController {
override func viewDidLoad() {
super.viewDidLoad()

let data: Data = Server.default.get("data")
let viewData: ViewData1 = ViewData1Converter().convert(data)

show(viewData)
}
}
```
Хорошо:
```Swift
class ViewController: UIViewController {
var server: ServerProtocol!
var converter: ConverterProtocol!

override func viewDidLoad() {
super.viewDidLoad()

let data: Data = server.get("data")
let viewData: ViewData1 = converter.convert(data)

show(viewData)
}
}
```

Как видим, в первом случае программа обращаемся к реализации сервера и создаем конвертер. При данном подходе очень сложно будет протестировать части системы отдельно. Более того, части системы будет сложно заменить, так как код типа: `Server.default` будет разбросан по всему проекту.

Но есть еще один аргумент в пользу DI, который нигде не пишется, но я считаю его весомым - указание внутри класса нужных ему зависимостей происходит отдельно от их внедрения. То есть происходит деление обязанностей на две части:
* Классы делают только то, что должны делать, не заботясь о зависимостях
* Классы, отвечающие за внедрение зависимостей, занимаются только этим и по ним можно легко понять, как взаимодействуют части системы между собой