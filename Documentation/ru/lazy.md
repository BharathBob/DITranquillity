# Инициализация в момент обращения

Swift имеет встроенное слово `lazy`, но к сожалению в отличии от опционалов это слово не имеет эквивалентов в обычных языковых конструкциях. В добавок оно распространяется только на свойства класса.

По этим причинам был добавлен свой тип `DILazy`, который может быть использован к методе инициализации, обычном методе, и в свойствах.

! Данный функционал не полный - например классы которые объявлены в `DILazy` обязаны иметь инициализацию без параметров. В реальности данное ограничение возможно обойти, но в силу того, что целесообразность данного функционала маленькая - оставлено на светлое будущее. Хотелось бы узнать мнение сообщества на счет этого класса - оставлять, улучшать, удалять?

## Объявление
Чтобы объявить переменную которая должна быть инициализирована в момент обращения, достаточно её тип включить в общий класс `DILazy`:
```Swift
class YourClass {
	let lazyValue: DILazy<YourOtherClass>
	init(lazyValue: DILazy<YourOtherClass>) {
		self.lazyValue = lazyValue
	}
}
```
Данный пример показывает как объявить `lazy` переменную через метод инициализации. При таком подходе сама переменная не будет создана. Это может иметь значение в нескольких случаях:
* Переменная использует данные которые могут должны появиться после её внедрения в класс, но перед её использованием
* Создание переменной это долгий процесс и есть шанс, что она вообще не понадобится

Так-как данный класс встроен в библиотеку, то он расчитан на то, что тип объявленный внутри `DILazy` зарегестрирован в библиотеке. Более того некоторые простые ошибки проверяются на этапе инициализации `lazy` класса, а не в момент инициализации переменной. Но проверяются только простые ошибки, которые можно проверить быстро и не прибегая к инициализации переменной.

## Использование
Для получения `lazy` переменной существует два синтаксиса:
```Swift
class YourClass {
	...
	func run() {
		// первый вариант через метод get() возращает исключения, такиеже как и при обычной инициализации
		let valueByGet = try! lazyValue.get()
		let optValue = try? lazyValue.get()

		// второй вариант - на прямую. Если будет ошибка во время создания то программа упадет с описанием ошибки
		let value = lazyValue.value
	}
}
```

Оба варианта являются кэширующими и потокобезопасными. То есть если два раза вызвать метод `get()` или обратится к переменной `value`, то будет создан всего один экземпляр класса, который при последующих обращения просто будет отдаваться.
Под потоко безопасностью имеется ввиду, что если два потока одновременно запросят переменную, то создастся только один экземпляр.

## Регистрация
Как и любой другой тип, для инициализации этого класс с помощью библиотеки нужно его зарегистрировать:
```Swift
builder.register {YourOtherClass() }
builder.register { scope in try! YourClass(lazyValue: scope.lazyResolve()) }
```
Обращаю внимание, что для того чтобы получить `lazy` класс, вызывается метод lazyResolve, а не обычный. Такое разгроничение нужно в силу того, что Swift не может вывести сам интерисующий его тип. Дабы избежать проблем, если написать обычный `resolve` в местах где упомянут `lazy` класс - то программа не скомпилируются.

## Быстрый синтаксис
Так как `lazy` разрешение зависимостей имеет не стандартный метод, по этим же причинам введен эквивалентный сокращенный синтаксис: `-*`, `-*!`, `-*?`, `-**`. Более подробно об этих операция можно прочитать в главе: [Разрешение зависимостей](resolve.md)


#### [Главная](main.md)
#### [Предыдущая глава "Поиск"](scan.md)
#### [Следующая глава "Исключения"](errors.md)
