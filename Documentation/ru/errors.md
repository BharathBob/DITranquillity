# Ошибки

В этой главе перечислены все ошибки, которые может кинуть библиотека. Каждая ошибка сделана так, чтобы дать как можно более подробную информацию о том, что произошло.


#### `DIError.typeIsNotFound(type:)`
**Кратко:**  
Нет компонента по указанному типу.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
type - тип, для которого не удалось найти компонент  
**Описание:**  
Возникает в случае если тип, который запрашивается, не был зарегистрирован. Чаще всего причиной ошибки является не внимательность.

#### `DIError.typeIsNotFoundForName(type:,name:,components:)`
**Кратко:**  
Нет компонента по указанному типу и имени.  
**Когда может возникнуть:**  
При вызове метода `resolve` с параметром `name` у контейнера  
**Параметры:**  
type - тип, для которого не удалось найти компонент с указанным именем  
name - имя, для которого не удалось найти компонент  
components - компоненты, которые были найдены для данного типа  
**Описание:**  
Возникает в случае если для запрашиваемого типа не зарегистрировано указанное имя. При этом если такой тип полностью не зарегистрирован в системе, то кинется ` typeIsNotFound`.

#### `DIError.notSpecifiedInitializationMethodFor(component:)`
**Кратко:**  
Не объявлен метод инициализации, и компонент не помечен как `perRequest`.  
**Когда может возникнуть:**  
При сборке компоненты  
**Параметры:**  
component - компонент, у которого нет метода инициализации  
**Описание:**  
Возникает, в случае если у компонента нет методов инициализации и компонент не имеет времени жизни `perRequest`.

#### `DIError.initializationMethodWithSignatureIsNotFoundFor(component:,signature:)`
**Кратко:**  
Нет метода инициализации с заданной сигнатурой для компоненты.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
component - компонент, который был выбран на основании указанного типа, или типа объекта  
signature - сигнатура метода, которую не удалось найти  
**Описание:**  
Возникает, в случае если не удалось найти метод инициализации с заданной сигнатурой. Под сигнатурой подразумевается количество и тип входящих параметров в метод инициализации.

#### `DIError.pluralSpecifiedDefaultType(type:, components:)`
**Кратко:**  
При множественной регистрации для одного типа указано более одной компоненты по умолчанию.  
**Когда может возникнуть:**  
При сборке компоненты  
**Параметры:**  
type - тип, для которого указано несколько компонентов  
components - все компоненты для этого типа  
**Описание:**  
Возникает если для типа указано в разных компонентах, что они являются компонентами по умолчанию и таких компонент более 1

#### `DIError.defaultTypeIsNotSpecified(type:,components:)`
**Кратко:**  
Не указан компонент по умолчанию.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
type - тип, для которого не указан компонент по умолчанию  
components - все компоненты для этого типа   
**Описание:**  
Возникает, если для типа есть более одной компоненты и библиотека не располагает данными чтобы выбрать какой именно ей нужен - нету компоненты отмеченной по умолчанию

#### `DIError.intersectionNamesForType(type:, names:, components:)`
**Кратко:**  
Для типа есть разные компоненты с одинаковыми именами.  
**Когда может возникнуть:**  
При сборке компоненты  
**Параметры:**  
type - тип, для которого пересекаются имена  
names - множество имен, которые пересекаются  
components - все компоненты для этого типа  
**Описание:**  
Возникает, если для типа есть более одной компоненты и у части этих компонент указаны имена так что эти имена пересекаются

#### `severalPerRequestObjectsFor(type: objects:)
**Кратко:**  
Для типа с временем жизни `perRequest` есть несколько объектов.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера для типа с временем жизни `perRequest`  
**Параметры:**  
type - тип, для которого есть несколько объектов  
objects - массив объектов заданного типа  
**Описание:**  
Возникает при попытке разрешить зависимости для типа, который имеет время жизни `perRequest`, но при этом в программе уже созданы объекты с таким типом и их больше одного.  
Возможность делать `resolve` для `perRequest` типов, была сделана для поддержки зависимостей между ViewController-ам

#### `DIError.typeIsIncorrect(requestedType:, realType:, component:)`
**Кратко:**  
Созданный тип объекта, не совпадает с типом, который был запрошен.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
requestedType - запрашиваемый тип  
realType - тип объекта, который был создан  
component - компонент, используемый для создания типа  
**Описание:**  
Из-за того что `asType` не проверяет правильность указанного типа, могут возникнуть ситуации, что создаваемый тип находиться в другой иерархии классов, нежели тип по которому он нашелся. Ошибка может возникнуть только при использовании `asType`, поэтому будьте внимательны, так как обнаружиться ошибка только во время исполнения.

#### `DIError.recursiveInitialization(component:)`
**Кратко:**  
Рекурсивная инициализация объекта.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
component - компонент, который содержит рекурсивную инициализацию  
**Описание:**  
Ошибка возникает если метод инициализации запрашивает создание самого себя или же это происходит через несколько уровней создания.
  
  
#### `DIError.build(errors:)`
**Кратко:**  
Ошибка для собирания других ошибок  
**Когда может возникнуть:**  
При сборке компоненты  
**Параметры:**  
errors - массив других ошибок  
**Описание:**  
Ошибка сама по себе таковой не является - это контейнер, который выдается наружу, если была обнаружена хотя бы одна ошибка во время сборки компоненты.

#### [Главная](main.md)
#### [Предыдущая глава "Поиск"](scan.md)
#### [Следующая глава "Примеры"](sample.md)
