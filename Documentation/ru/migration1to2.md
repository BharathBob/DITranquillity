# Миграция с версии 1.x.x на версию 2.x.x
Перед миграцией взвесте все за и против, так-как изменения достаточно колосальные. При этом новые возможности возможно вам и не нужны.

## Новые возможности
* Удален `DynamicAssembly`, за место него теперь позднее связывание - можно разделить объявление и реализацию интерфейса.
* Проверка альтернативных типов во время компиляции - которые задавались через `asType`
* Добавлено описание ошибок за место ихнего обычного вывода
* Добавлена поддержка стека вызова -> теперь при правильном использовании можно узнать не только причину, но и место откуда было вызвано, и какие типы были созданы в середине.
* Сильна улучшена автоматика при регистрации. Теперь можно напрямую передавать `init` функцию, и получать готовые значения для внедрения через свойствам.
* Добавлен `weak single`
* Добавлена возможность синхронизации двух контейнеров, так чтобы они имели одни и теже объекты с областью видимости `perScope`
* Улучшено деление на части - если вы чтото не используете, это можно не включать в проект.
* Поддержка автоматического внедрения через свойства класса. Работает только для наследников от `NSObject`
* Сильное изменение синтаксиса, на более краткий и понятный

Если эти возможности не являются для вас критичными, и проект не планируется развиваться еще очень долго, то не стоит проводить миграцию.

## Разделение в cocoapods
Начну пожалуй с установки. Теперь весь проект делиться на составные части:
* Core
* Description
* Component
* Module
* Storyboard
* Scan
* RuntimeArgs

По умолчанию устанавливаются следующие части: Core, Description, Component, Module, Storyboard.
По этой причине, если вы использовали возможности сканирования, или передачу аргументов во время исполнения, то стоит включить эти части при установке.
Для упрощения подобной ситуации, существует отдельно выделенная часть: `Full` - в неё включаются все остальные части.
Пример использования:
`pod 'DITranquillity/Description'` - установить поддержку описания
`pod 'DITranquillity/Module'` - установить поддержку модулей
Ядро включается всегда

## Переименования
Начну с самой главной части - переименования.
### При регистрации типа
Название самой функции также претерпело изменения: `register() -> register(type:)` - но если вы использовали closure, то это изменение вас не коснется. 
* `initializer` -> `initial`
* `dependency` -> `injection`
* `asType` -> `as` (также см. ниже)
* `initializerDoesNotNeedToBe` -> `initialNotNecessary`
* `asSelf` -> `as(.self)`
* `asName` -> `set(name:)`
* `asDefault`- > `set(.default)`
* `initial(byNib:)` -> `initial(nib:)`
* `initial(byStoryboard:)` -> `initial(useStoryboard:)`

### Сборки, модули, компоненты
Я окончательно отошел от именования принятого у тайфуна, и назвал вещи своими именами.
* `DIModule` -> `DIComponent`
* `DIAssembly` -> `DIModule`
* `publicModules`, `internalModules` -> `components` (также см. ниже)
* `register(module:)` -> `register(component:)`
* `register(assembly:)` -> `register(module:)`
Обращаю внимание на пересечение имен, поэтому обязательно переменуйте вначале модуль в компонент, дабы избежать коллизий имен.

## Удаленные возможности
* Регистрация типа с runtime аргументами через функцию `register`. см. ниже
* Инициалицизая типа с runtime аргументами через функцию `initial`.
Теперь существует всего одна возможность это сделать: функция `initialWithArg`.  
Причина: сложность понимания когда используются рантайм аргументы, а когда обычное внедрение. И достаточная редкость использования рантайм аргументов.
* `DILazy` который появился в версии 1.3.1.  
Причина: Противоречие концепции библиотеки - нужно использовать "настоящее внедрениее зависимостей"
* `*!` и `**!`  
Причина: Исключения возникающие внутри операций должны прокидываться наверх. Данные операции правоцируют на игнорирование ошибки, и падению в месте где возникла проблема, что не всегда удобно.

## Расширение старых возможностей
* Передача init функции при использовании метода `register(type:)` или `initial()`.  
Пример: `builder.register(type: YourClass.init(p1:p2:)`
* Внедрение свойств без использования контейнера.  
Пример: `.injection { $0.value = $1 }` или `.injection { obj, value in ibj.value = value }`
* Обязательная! проверка альтернативного типа во время компиляции: `as(YourProtocol.self).check{$0}`. Так как старое использование не обязывало в функции `register` указывать тип возращаемого объекта, хоть и было желательным, то существует способ проигнорировать проверку: `as(YourProtocol.self).unsafe()`
* Функции `register(type:)`, `initial`, `injection`, `initialWithArg` теперь пробрасывают исключения наверх. По этой причине настоятельно рекомендую убрать из них все `try!` и заменить на обычный `try`.

## Новые возможности
* Позднее связывание: у функции `as` появился дополнительный синтаксис: `as(YourProtocol.self).scope(.global).check{$0}` - который позволяет указать область видимости класса реализации протокола: `global` или `module`. `module` используется по умолчанию, и означает, что реализация протокола будет видна только если она была явна зарегестрирована при создании контейнера. `global` после того как был создан хотябы один контейнер с этой реализацией, реализация будет доступна и в других контейнерах если они знают об интерфейсе. Обращаю внимание, что это почти обычный тип и на него распространяются теже правила. Например ему можно задать имя, или сделать его по умолчанию.
* Указание области видимости у компоненты: Теперь для указания области видимости по аналогии со старыми `publicModules` и `internalModules`, их нужно указывать у каждой компоненты отдельно. По умолчанию все компоненты используют `internal`. Для изменения на `public` у компоненты нужно написать следующий образом:  
```swift
class YourComponent: DIComponent {
  var scope: DIComponentScope { return .public }
  func load(builder: DIContainerBuilder) ...
}
```
* По аналогии с другими DI контейнерами я добавил еще одну области видимости: `.weakSingle`. То есть объект живет, до тех пор пока не будут потеряны все ссылки на него, после чего он будет пересоздан.
* Автоматическое внедрение свойств. Эта возможность работает только для классов отнаследованных от `NSObject`. Причем наследоваться должен как класс хранящий свойства, так и сами свойства. Для указания факта, что вы хотите использовать автоматическое внедрение при регистрации типа нужно использовать функцию: `useAutoPropertyInjection`. У этой возможности есть два существенных плюса: Все внедрения проходят сами и появление нового свойства не заставляет его указывать в регистрации; Эти свойства можно объявить `private` и они всеравно смогут внедриться. То есть можно избежать проблем с инкапсулящией.


Для получения более подробной информации о расширении старых и появлении новых возможностях, смотрите обновленную документацию. На текущий момент обновление документации в стадии разработки.
