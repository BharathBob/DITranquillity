# Регистрация
Любая регистрация происходит с помощью ключевого метода `register`, у экземпляра класса `DIContainerBuilder`. Прежде чем начать регистрировать что либо, нужно в системе создать как миниум один экземпляр класса `DIContainerBuilder`:
```Swift
let builder = DIContainerBuilder()
```
С этого места и далее, если в документации встречается объект с именем `builder`, то это означает, что это экземпляр класса `DIContainerBuilder`.

Существует три базовых регистрации:
* Тип `register(type:`
* Компонент `register(component:`
* Модуль `register(module:`
Некоторые части системы, дополняют регистрацию дополнительными возможностями, о которых будет описана в главе про эту часть.

## Регистрация типа
Самая часто всречаемая регистрация. Далее в этой главе будет рассказано только о регистрации по типу. Другие способы регистрации, можно найти в главах: [компонент](component.md), [модуль](module.md), [storyboard](storyboard.md)

При такой регистрации системе сообщается тип, по которому будет доступен объект.
!! При разделении регистрации на две части: объявление типа и объявление метода инициализации, настоятельно рекомендую указывать один и тотже тип. Это не обязательное условие так как при объявлении типа можно указать любой родитеский класс. Но для лучшей поддержки всех дальнейших операций, лучше чтобы типы совпадали.

Для того чтобы в системе зарегистрировать тип нужно указать его в ключевом методе:
```Swift
builder.register(type: Cat.self) // Регистрация типа `Cat`
```
Это не единственный способ регистрации по типу остальные будут разобраны ниже.

## Указание метода инициализации
Предыдущий код не может считаться полным, так как библиотека не умеет автоматически выводить метод инициализации для любого типа. Чтобы тип был полностью зарегистрирован в системе, нужно указать метод инициализации. Для этого можно использовать closure в котором инициализировать объект. Если метод инициализации принимает на вход только простые зависимости, то можно указать сам метод инициализации:
```Swift
builder.register(type: Cat.self).initial{ Cat() } // через closure
builder.register(type: Cat.self).initial(Cat.init) // через метод инициализации
```

Такой способ является универсальным, и благодаря статической типизации нельзя указать не тот создаваемый объект, но имеет недостаток - тип указывается дважды. Поэтому существует короткая запись:
```Swift
builder.register{ Cat() } // через closure
builder.register(type: Cat.init) // через метод инициализации
```

## Указание альтернативных типов
Помимо указанного типа при регистрации можно указать альтернативные типы, по которому будет доступен объект. Чаще всего альтернативными типами выступают протоколы. 

Указание альтернативного типа, происходит с помощью метода `as`:
```Swift
builder.register(type: Cat.self).as(Animal.self)...
```

!!! Если указан альтернативный тип, то разрешение зависимостей возможно только по этому типу - базовый тип будет утерен, если не указано обратного. Для примера выше объект будет доступен только по имени `Animal`.
Чтобы объект `Cat` был доступен по типу `Cat` и `Animal`, можно или продублировать тип, что не желательно, или воспользоваться методом `as(.self)`:
```Swift
builder.register(type: Cat.self).as(.self).as(Animal.self)....
```

Во второй версии библиотеки, синтаксис функции `as` стал более сложным, он обязывает проверить тип. Если этого не сделать запись будет проигнорирована. Чтобы проверить тип нужно использовать функцию `check`:
```Swift
builder.register(type: Cat.self).as(Animal.self).check{$0}
```

Если вы любите стрелять себе в ногу, или вы решили не следовать совету про указание одного и тогоже типа в регистрации и методе инициализации, существует способ указать альтернативный тип без проверки:
```Swift
builder.register(type: Cat.self).as(Animal.self).unsafe()
```

Помимо этого функцию с проверкой, можно переписать более коротким образом - без указания функции `check`:
```Swift
builder.register(type: Cat.self).as(Animal.self, check: {$0})
builder.register(type: Cat.self).as(Animal.self){$0}
```
!! Обращаю внимание, что отдельная функция была сделано не просто так, а по причине недоработанности компилятора Swift - в случаи отдельной функции если тип невалиден, то компилятор так и напишет, во втором же случае он напишет, что функция as с такими аргументами не найдена.

## Разрешение зависимостей при инициализации
Если класс имеет зависимости от других классов, то их надо указать. Указать зависимости можно тремя способами:
* Через метод инициализации (конструктор)
* Через свойства
* Через любой другой метод

Для указания зависимостей, нужно получить контейнер, и у него уже попросить интерисующий нас объект:
```Swift
builder.register(type: Home.self).initial { (container) in try Home(cat: container.resolve()) }
builder.register{ (container) in try Home(cat: container.resolve()) }
```
Более подробную информацию можно прочитать в главе [Разрешение зависимостей](resolve.md)

Если инициализация объекта состоит только из объектов которые нужно внедрять, то можно воспользоваться более короткой записью:
```Swift
builder.register(type: Home.self).initial(Home.init(cat:))
builder.register(type: Home.init(cat:))
```

И существует вариант, записи, являющийся чемто средним между первым и вторым:
```Swift
builder.register(type: Home.self).initial{ Home(cat:$0) }
builder.register{ Home(cat:$0) }
```

!! Внимание. второй и третий вариант не поддерживает множественное разрешение зависимостей, также как и опциональное. Внутри всегда используется обычный `try` и обычный метод `resolve`.

## Разрешение зависимостей после инициализации
Для указания зависимостей через свойства или любой другой метод, надо перед этим создать объект, в который мы будем внедрять зависимости. Можно это сделать и внутри блока, в котором создается объект, но такой способ не предпочтителен. Для таких случаев существует метод `injection`, который может быть написан несколько раз: 
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { container, home in try home.animals.append(container.resolve(Cat.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Dog.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Hamster.self)) }
```
Данный метод очень похож на метод инициализации, но у него есть одно главное отличие: вторым аргументом он принимает созданный объект.

По аналогии с методом инициализации, этот метод поддерживает похожие способы сокращения:
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { home, cat in home.animals.append(cat as Cat) }
  .injection { $0.animals.append($1 as Dog) }
  .injection { $0.hamster = $1 } // автоматически выведет тип
```
!! Обращаю внимание на существенное отличие - в первом случае нулевым параметром идет контейнер, а первым объект. Во втором же случае нулевым параметром идет объект в который внедряются зависимости, а за ним уже идут объекты которые внедряются.

## Автоматическое внедрение зависимостей через свойства
Если вы не используете чистые Swift типы, что является частично правдой, так как UI является Obj-C кодом, то существует способ автоматически внедрить все зависимости через свойства без необходимости их перечислять. Но это накладывает два ограничения:
* Тип в который внедряются должен быть отнаследован от `NSObject`
* Тип который внедряется должен быть отнаследован от `NSObject`
Но при этом снимает ограничение на область видимости - типы могут быть и приватными.
В моем понимании самое удачное применение этой возможности является ViewController:
```Swift
class YourViewController: UIViewController {
  private var inject1: Inject1!
  private var inject2: Inject2!
  ...
}
```
А теперь, давайте сравним два синтаксиса для внедрения (обращаю внимание, что для старого варианта нужно убрать `private`):
```Swift
/// Старый
builder.register(vc: YourViewController.self)
  .inject { vc, inject in vc.inject1 = inject }
  .inject { vc, inject in vc.inject2 = inject }
  .inject { vc, inject in vc.inject3 = inject }
  ...

/// Новый
builder.register(vc: YourViewController.self)
  .useAutoPropertyInjection()
```
Новый вариант дал правильный вариант для области видимости, и по факту наложил всего одно ограничение: `Inject1`, `Inject2`,... должны быть отнасделованы от `NSObject`.

## Циклические ссылки
Метод `injection` существует, не только для улучшения читабельности кода, но он также выполняет еще одну важную функцию: благодаря нему, возможно указание циклических зависимостей:
```Swift
class Cat: Animal {
  init(home: Home) { ... }
}
class Home {
  var animals: [Animal] = []
}

...
builder.register(type: Cat.self).initial { c in Cat(home: c.resolve()) }
builder.register{ Home() }.injection { $0.animals.append($1 as Cat) }
```
Как видим, в данном примере Кошка знает, где её дом, а дом знает, что в нем живет кошка. Если бы кошка и дом указывали свои зависимости в методе инициализации, то библиотека не смогла бы создать ни кошку, ни дом, так как на момент создания пары, один из объектов еще не создан.

Библиотека не требует указывать явно, что имеются циклические зависимости. Во время разрешения зависимостей библиотека анализирует ситуацию и сама решает, есть ли циклические зависимости или нет.

!! Данный пример является одним из самых простых вариантов циклической зависимости. В библиотеке имеется 7 различных тестов, которые проверяют разные варианты циклических зависимостей для 2, 3 объектов и если объекты внедряются дважды.

## Передача параметров во время исполнения
!! Данный функционал доступен только если его подключить отдельно.
В некоторых случаях чтобы создать объект, нужна дополнительная информация, которую мы можем получить только в ходе исполнения программы. К примеру есть класс `Dog`, но кличка собаки заранее не известна:
```Swift
class Dog {
  init(name: String) { ... }
}

...
builder.register(type: Dog.self).initialWithArg { _, name in Dog(name: name) }
```
В примере объявляется тип `Dog` и указывается ему метод инициализации, принимающий имя собаки. Обращаю внимание, что при указании параметров всегда присутствует первый параметр `container`.

Библиотека допускает указать через запятую неограниченное количество параметров (на самом деле до 10, но это число легко расширяется). 

Чтобы не ограничивать пользователя библиотекой была добавлена возможность указывать неограниченное количество методов инициализации, но с одним условием - все методы должны иметь разную сигнатуру по типам и количеству типов:
```Swift
class Hamster {
  init(name: String) { ... }
  init(name: String, species: String) { ... }
  ...
}
...
builder.register(type: Hamster.self)
  .initialWithArg { _, name in Hamster(name: name) }
  .initialWithArg { _, name, species in Hamster(name: name, species: species) }
```
В примере выше тип `Hamster` имеет два метода инициализации, с разным количество параметров.

Swift позволяет записать эту запись короче:
```
builder.register(type: Hamster.self)
  .initialWithArg { Hamster(name: $1) }
  .initialWithArg { Hamster(name: $1, species: $2) }
```
!! Обращаю внимание, что все параметры начинаются с 1, а не с 0, так как под 0 доступно обращение к container.

#### [Главная](main.md)
#### [Следующая глава "Создание контейнера"](build.md)
