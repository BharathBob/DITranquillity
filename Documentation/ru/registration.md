# Базовая Регистрация зависимостей

## Регистрация зависимости
При регистрации зависимости обязательным к указанию является две вещи: тип и метод инициализации (есть исключение когда метод инициализации не обязательно указывать, он нём будет сказано в главе о Storyboard)

Пример регистрации класса 'Cat'
```Swift
builder.register(Cat)
```

## Метод инициализации
Метод инициализации это функция, которая возвращает тип указанный при регистрации. В этом месте присутствует статическая проверка типов, поэтому возвращаемое значение обязательно будет удовлятворять заданному типу. 
В простейшем случае, регистрация класса 'Cat' с указанием метода инициализации, выглядит следующим образом:
```Swift
builder.register(Cat).initializer { _ in return Cat() }
```

## Указание альтернативных типов
Помимо указанного типа при регистрации, можно указать альтернативные типы, по которому будет происходить разрешение зависимостей. При этом если указан альтернативный тип, то по базовому типу разрешение зависимостей происходить не будет, если не указано обратного. 
Внимание! В силу ограничений языка swift, альтернативный тип можно указать полностью любым, и проблемы обнаружатся лишь при разрешении зависимости. 

Если мы хотим чтобы наш класс 'Cat' был доступен по типу 'Animal', то мы можем написать следующий код:
```Swift
builder.register(Cat).asType(Animal).initializer { _ in return Cat() }
```
Но такое написание, не позволит обращаться напрямую по типу 'Cat'. Если же мы хотим обращаться по обоим типа то, нужно написать:
```Swift
builder.register(Cat).asSelf().asType(Animal).initializer { _ in return Cat() }
```

## Разрешение зависимостей при инициализации
В большинстве случаев, когда мы создаем некий класс у него есть зависимости от других классов. Разрешать эти зависимости можно разными способами: передавать в конструкторе, передавать через специальные методы, обращаться на прямую к свойству. В данной библиотеке доступны все эти способы, и сейчас мы увидим как легко можно разрешить зависимости через передачу в констукторе:
```Swift
Home(myCat: Cat) { ... }
...
builder.register(Home).initializer { scope in return Home(myCat: try! scope.resolve()) }
```
Из примера видно, что ничего сложно нету - в метод инициализации передается текущий scope (в котором происходило разрешение зависимости для Home), и мы используя данный scope можем у него запросить класс 'Cat'. При этом мы не указываем что данный класс должен быть именно 'Cat', так как компилятор может сам вывести тип. Так как при инициализации могут возникнуть проблемы (не найден тип, или заявленный тип не совпадает с реальным) то надо обработать исключение. В данном примере показан простой способ обработки исключения - мы явно говорим, что его не должно произойти.
Более подробная информация про разрешение зависимостей написанна в следующей главе. Но в данном месте покажем более короткую запись разрешения зависимостей:
```Swift
builder.register(Home).initializer { s in return Home(myCat: *!s) }
```

## Методы для добавления зависимостей
Как было написанно выше, разрешать зависимости мы можем не только при инициализации, но и позже.
Рекомендация! Не надо в методе инициализации писать код, который разрешает зависимости каким либо способом отличным от разрешения через конструктор.
Для этого существует отдельный метод, который можно объявить несколько раз, для большей читабельности. Более того такой способ позволит нам в дальнейшем разрешать циклические зависимости.
Например мы решили, что дом може содержать несколько животных, и в целях примера покажем способ как это сделать без использования разрешения зависимостей при инициализации:
Информация! На самом деле еслибы животные хранили внутри себя ссылку на дом, то данная реализация былабы предпочтительнее, нежели разрешение в инициализации.
```Swift
class Home {
  var animals: [Animal] = []
}

builder.register(Home).initializer { s in return Home() }
  .dependency { s, home in home.animals.append(s.resolve(Cat)) }
  .dependency { s, home in home.animals.append(s.resolve(Dog)) }
  .dependency { s, home in home.animals.append(s.resolve(Hamster)) }
```

В данном примере мы видим, как мы к дому добавили 3 животных - кошку, собаку и хомяка.
Любой такой метод принимает scope и ссылку на объект который был создан в методе инициализации. Данный метод типизирован - то есть ссылка на объект совпадает с типом который был указан при регистрации.

## Циклические ссылки
В прошлом парагрофе мы разобрали как можно внедрять зависимости после инициализации. Теперь предположим, что кот умное животное и помнит о своём доме в котором он живет. Так как мы уже написали внедрение зависимостей через отдельные методы, то мы можем спокойно написать следующий код:
```Swift
class Cat {
  init(home: Home) { ... }
  ...
}
...
builder.register(Cat).initializer { s in return Cat(home: s.resolve()) }
```
Теперь не зависимо от того что мы создаем (кошку или дом) у них будут ссылки друг на друга.
Внимание! Циклически ссылки работаю в 3 случая из 4: dependency - dependency, dependency-initializer, initializer-dependency. Циклически ссылки не работаю на случай: initializer-initializer.
Внимание! На текущий момент если мы для Home напишем два раза: `.dependency { s, home in home.animals.append(s.resolve(Cat)) }` то это приведет не к тому поведению, которое бы ожидалось - кот не будет создан два раза - один и тотже кот добавиться два раза массив.

## Передача параметров
Иногда при разрешении зависимости, бывают случаи что мы хотим передать параметры в функцию инициализации. Предположим, что мы решили, давать собаке кличку, но она может быть разной для разных собак. Данный функционал мы можем описать следующим образом:
```Swift
class Dog {
  init(name: String) { ... }
  ...
}
...
builder.register(Dog).initializer { s, name in return Dog(name: name) }
```

Как видим из кода выше добавление дополнительного параметра, не представляет сложности - после объявления scope мы может через запятую объявить любое количество параметров (до 10), и они будут доступны из вне.
Так как у классов может быть много конструктор, то и методов инициализации мы можем указать несколько. К примеру мы хотим чтобы у хомяка было тоже имя, но еще у него может быть собственный домик, а может и не быть. Напишем данный пример:
```Swift
class Hamster {
  init(name: String) { ... }
  init(name: String, hamsterHome: HamsterHome) { ... }
  ...
}
...
builder.register(Hamster)
  .initializer { s, name in return Hamster(name: name) }
  .initializer { s, name, hamsterHome in return Hamster(name: name, hamsterHome: hamsterHome) }
```
Методов инициализации может быть много, но они не могут пересекаться - то есть не может быть два метода инициализации которые принимают одни и теже типы в одинаковой последовательности. то есть сигнатура вида `String, Int` не может повторятся дважды, но `Int, String` является другой сигнатурой, и может присутствовать вместе с первой.


