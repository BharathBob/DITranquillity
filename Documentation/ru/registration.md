# Регистрация
Все компоненты регистрируются с помощью ключевого метода `register`, у экземпляра класса `DIContainerBuilder`. Прежде чем начать регистрировать компоненты, нужно в системе создать как миниум один экземпляр класса `DIContainerBuilder`:
```Swift
let builder = DIContainerBuilder()
```
С этого места и далее, если в документации встречается объект с именем `builder`, то это означает, что мы его создали с помощью кода выше.

## Основной способ регистрации
Основным способом регистрации компонентов, является регистрация по типу. Все остальные способы регистрации, так или иначе, следуют из этого.

При такой регистрации системе сообщается тип, по которому будет доступен объект. Так как любой объект также имеет тип, то должно выполняться обязательное требование - тип по которому доступен в системе компонент, должен быть таким же или родителем типа объекта.
К примеру, если у нас класс `C` наследуется от `B`, а `B` от `A`, то объект класса `C` может быть доступен в программе по типу `C`, `B`, `A`.

Для того чтобы в системе зарегистрировать тип нужно указать его в ключевом методе:
```Swift
builder.register(Cat.self) // Регистрация типа `Cat`
```
Это не единственный способ регистрации по типу остальные будут разобраны ниже.

## Указание метода инициализации
Предыдущий код не может считаться полным, так как библиотека не умеет автоматически выводить метод инициализации для любого типа. Чтобы тип был полностью зарегистрирован в системе, для этого типа нужно указать метод инициализации:
```Swift
builder.register(Cat.self).initializer { Cat() }
```

Такой способ является универсальным, и благодаря статической типизации нельзя указать не тот создаваемый объект, но имеет недостаток - тип указывается дважды. Для случаев, когда тип создаваемого объекта совпадает с типом в системе, есть короткая запись:
```Swift
builder.register{ Cat() }
```

## Указание альтернативных типов
Помимо указанного типа при регистрации можно указать альтернативные типы, по которому будет доступен объект. При этом если указан альтернативный тип, то по базовому типу разрешение зависимостей происходить не будет, если этого не указано явно. 
Внимание! В силу ограничений языка Swift, альтернативный тип можно указать полностью любым и проблемы обнаружатся лишь при создании объекта. 

Указание альтернативного типа, происходит с помощью метода `asType`:
```Swift
builder.register(Cat.self).asType(Animal.self).initializer { Cat() }
```
При такой записи, объект `Cat` будет доступен только по имени `Animal`, так как базовый тип перетирается. Чтобы объект `Cat` был доступен по типу `Cat` и `Animal`, надо или написать `asType` два раза, или воспользоваться методов `asSelf`:
```Swift
builder.register(Cat.self).asSelf().asType(Animal.self).initializer { Cat() }
```


## Разрешение зависимостей при инициализации
Если класс имеет зависимости от других классов, то их надо указать. Указать зависимости можно тремя способами:
* Через метод инициализации (конструктор)
* Через свойства
* Через любой другой метод

Для указания зависимостей, нужно получить специальный объект, который знает о нужных компонентах в системе:
```Swift
builder.register(Home.self).initializer { (scope) in ... }
```
В данном коде `scope` является тем специальным объектом. Для того чтобы получить объект воспользуемся функцией `resolve` у `scope`:
```Swift
builder.register(Home.self).initializer { scope in return Home(сat: try! scope.resolve(Cat.self)) }
```
Существуют другие способы получения объектов из `scope`, более подробно об этом и об исключениях написано в главе [Разрешение зависимостей](resolve.md).

Но, чтобы показать возможности библиотеки, я позволю себе записать тот же код в короткой записи:
```Swift
builder.register{ Home(cat: *!$0) }
```
Такая запись намного короче предыдущей и использует как возможности языка, так и возможности библиотеки.

## Разрешение зависимостей после инициализации
Для указания зависимостей через свойства или любой другой метод, надо перед этим создать объект, в который мы будем внедрять зависимости. Можно это сделать и внутри блока, в котором создается объект, но такой способ не предпочтителен. Для таких случаев существует метод `dependency`, который может быть написан несколько раз: 
```Swift
builder.register(Home.self).initializer { Home() }
  .dependency { scope, home in try! home.animals.append(scope.resolve(Cat.self)) }
  .dependency { scope, home in try! home.animals.append(scope.resolve(Dog.self)) }
  .dependency { scope, home in try! home.animals.append(scope.resolve(Hamster.self)) }
```
Данный метод очень похож на метод инициализации, но у него есть одно главное отличие: вторым аргументом он принимает созданный объект.

Позволю себе еще раз переписать пример, на короткую запись:
```Swift
builder.register{ Home() }
  .dependency { $1.animals.append(*!$0 as Cat) }
  .dependency { $1.animals.append(*!$0 as Dog) }
  .dependency { $1.animals.append(*!$0 as Hamster) }
```

## Циклические ссылки
Метод `dependency` существует, не только для улучшения читабельности кода, но он также выполняет еще одну важную функцию: благодаря ему, возможно указание циклических зависимостей:
```Swift
class Cat: Animal {
  init(home: Home) { ... }
}
class Home {
  var animals: [Animal] = []
}

...
builder.register(Cat.self).initializer { scope in return Cat(home: scope.resolve()) }
builder.register{ Home() }.dependency { $1.animals.append(*!$0 as Cat) }
```
Как видим, в данном примере Кошка знает, где её дом, а дом знает, что в нем живет кошка. Если бы кошка и дом указывали свои зависимости в методе инициализации, то библиотека не смогла бы создать ни кошку, ни дом, так как на момент создания пары, один из объектов еще не создан.

Библиотека не требует указывать явно, что имеются циклические зависимости. Во время разрешения зависимостей библиотека анализирует ситуацию и сама решает, есть ли циклические зависимости или нет.

P.S. Данный пример является одним из самых простых вариантов циклической зависимости.

! Данный функционал существует и рабочий, но его нужность остается под вопросом, так как по факту циклические ссылки нужны в очень редких случаях и скорей всего при этом можно использовать стандартные средства языка. Так-как данный функционал достаточно сложен и увеличивает размер приложения, есть шанс, что он будет удален. Но перед этим хотелось бы узнать мнение сообщества.

## Указание параметров при инициализации
В некоторых случаях чтобы создать объект, нужна дополнительная информация, которую мы можем получить только в ходе исполнения программы. Так мы можем иметь класс `Dog`, но кличку собаке мы будем получать во время исполнения:
```Swift
class Dog {
  init(name: String) { ... }
}

...
builder.register(Dog.self).initializer { _, name in return Dog(name: name) }
```
В примере объявляется тип `Dog` и указывается ему метод инициализации, принимающий имя собаки. Обращаю внимание, что при указании параметров всегда присутствует первый параметр `scope`.

Библиотека допускает указать через запятую неограниченное количество параметров (на самом деле до 10, но это число возможно изменить). 

Чтобы не ограничивать пользователя библиотекой была добавлена возможность указывать неограниченное количество методов инициализации, но с одним условием - все методы должны иметь разную сигнатуру по типам и количеству типов:
```Swift
class Hamster {
  init(name: String) { ... }
  init(name: String, species: String) { ... }
  ...
}
...
builder.register(Hamster.self)
  .initializer { _, name in return Hamster(name: name) }
  .initializer { _, name, species in return Hamster(name: name, species: species) }
```
В примере выше тип `Hamster` имеет два метода инициализации, с разным количество параметров.

В очередной раз позволю себе написать короткую форму записи данного примера:
```
builder.register(Hamster.self)
  .initializer { Hamster(name: $1) }
  .initializer { Hamster(name: $1, species: $2) }
```
Обращаю внимание, что все параметры начинаются с 1, а не с 0, так как под 0 доступно обращение к scope.

Но, можно вспомнить, что метод инициализации мы можем объединить с регистрацией типа и получить еще более короткую запись:
```
builder.register{ Hamster(name: $1) }
  .initializer { Hamster(name: $1, species: $2) }
```

#### [Главная](main.md)
#### [Следующая глава "Создание контейнера"](build.md)
