# Внедрение
Частично внедрение зависимостей было рассмотрено в предыдущей главе - внедрение через метод инициализации. Но существует два других варианта внедрения: через свойства и через методы.

## Внедрение зависимостей
Для указания зависимостей через свойства или любой другой метод, надо перед этим создать объект, в который мы будем внедрять зависимости. Можно это сделать и внутри блока, в котором создается объект, но такой способ не предпочтителен. Для таких случаев существует метод `injection`, который может быть написан несколько раз: 
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { container, home in try home.animals.append(container.resolve(Cat.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Dog.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Hamster.self)) }
```
Данный метод очень похож на метод инициализации, но у него есть одно главное отличие: вторым аргументом он принимает созданный объект.

По аналогии с методом инициализации, этот метод поддерживает похожие способы сокращения:
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { home, cat in home.animals.append(cat as Cat) }
  .injection { $0.animals.append($1 as Dog) }
  .injection { $0.hamster = $1 } // автоматически выведет тип
```
!! Обращаю внимание на существенное отличие - в первом случае нулевым параметром идет контейнер, а первым объект. Во втором же случае нулевым параметром идет объект в который внедряются зависимости, а за ним уже идут объекты которые внедряются.

## Автоматическое внедрение зависимостей через свойства
Если вы не используете чистые Swift типы, что является частично правдой, так как UI является Obj-C кодом, то существует способ автоматически внедрить все зависимости через свойства без необходимости их перечислять. Но это накладывает два ограничения:
* Тип в который внедряются должен быть отнаследован от `NSObject`
* Тип который внедряется должен быть отнаследован от `NSObject`
Но при этом снимает ограничение на область видимости - типы могут быть и приватными.
В моем понимании самое удачное применение этой возможности является ViewController:
```Swift
class YourViewController: UIViewController {
  private var inject1: Inject1!
  private var inject2: Inject2!
  ...
}
```
А теперь, давайте сравним два синтаксиса для внедрения (обращаю внимание, что для старого варианта нужно убрать `private`):
```Swift
/// Старый
builder.register(vc: YourViewController.self)
  .inject { vc, inject in vc.inject1 = inject }
  .inject { vc, inject in vc.inject2 = inject }
  .inject { vc, inject in vc.inject3 = inject }
  ...

/// Новый
builder.register(vc: YourViewController.self)
  .useAutoPropertyInjection()
```
Новый вариант дал правильный вариант для области видимости, и по факту наложил всего одно ограничение: `Inject1`, `Inject2`,... должны быть отнасделованы от `NSObject`.

## Циклические ссылки
Метод `injection` существует, не только для улучшения читабельности кода, но он также выполняет еще одну важную функцию: благодаря нему, возможно указание циклических зависимостей:
```Swift
class Cat: Animal {
  init(home: Home) { ... }
}
class Home {
  var animals: [Animal] = []
}

...
builder.register(type: Cat.self).initial { c in Cat(home: c.resolve()) }
builder.register{ Home() }.injection { $0.animals.append($1 as Cat) }
```
Как видим, в данном примере Кошка знает, где её дом, а дом знает, что в нем живет кошка. Если бы кошка и дом указывали свои зависимости в методе инициализации, то библиотека не смогла бы создать ни кошку, ни дом, так как на момент создания пары, один из объектов еще не создан.

Библиотека не требует указывать явно, что имеются циклические зависимости. Во время разрешения зависимостей библиотека анализирует ситуацию и сама решает, есть ли циклические зависимости или нет.

!! Данный пример является одним из самых простых вариантов циклической зависимости. В библиотеке имеется 7 различных тестов, которые проверяют разные варианты циклических зависимостей для 2, 3 объектов и если объекты внедряются дважды.

ыы
#### [Главная](main.md)
#### [Предыдущая глава "Регистрация"](registration.md)
#### [Следующая глава "Создание контейнера"](build.md)
