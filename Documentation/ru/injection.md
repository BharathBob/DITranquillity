# Внедрение
Одни из способ внедрения был разобран в предыдущей главе, а именно внедрение через метод инициализации. Несмотря на то, что данный метод внедрения является самым простым и наилучшим, не стоит упускать из виду и два других способа: через свойства или через методы.
Эти два способа позволяют внедрять зависимости в объекты которые были уже созданы кемто другим, в частности ViewController-ы, и также создавать циклические зависимости.
Также из плюсов, внедрение через свойство позволяет указывать имя как модификатор для получения объекта, в отличии от других способов.

## Внедрение зависимостей через свойства
Второй по частоте использования, это внедрение через свойства. На самом деле на своей практике я ни разу не встречал внедрение через метод, но оставляю эту возможность.
Почему этот способ столь популярен у Apple систем? Потому что в большинстве случаев ViewController создается из storyboard, а значит мы не имеем доступ к методу инициализации.
Внедрение через свойства обладает недостаток - что в этом случае эти свойства становятся изменяемыми, и доступные другим классов. То есть нарушается инкапсуляция, что не есть хорошо.
Но всеже давайте рассмотрим как это делается с помощью библиотеки. Для внедрение через свойство, как и через методы есть ключевой метод `injection` при регистрации компонента:
```Swift
container.register(Home.init)
  .injection { home, dog in home.animals.append(dog as Dog) }
  .injection { $0.animals.append($1 as Cat) }
  .injection { $0.hamster = $1 }
```
Как видим внедрении через свойства ничего сложного не представляет, более того у него работает ассист, который будет вам помогать. У этого способа во всю используется автоматический вывод типов, что позволяет писать короткий код, к которому быстро привыкаешь, и дазе без указания имени переменных становится все понятно. Более того указание типа за частую не нужно, как в 3 варианте - он может быть выведен автоматически.
Порядок внедрения совпадает с порядком объявления, за исключением наличия циклических ссылок, о которых речь пойдет ниже.

Давайте посмотрим на более сложные ситуации - если нам надо получить объект по имени, тегу, или множество всех, то есть когда используются модификаторы:

```Swift
container.register(Home.init)
.injection(name: "dog") { $0.animals.append($1 as Animal) }
.injection { $0.animals.append(contentsOf: many($0) as [Animal]) }
.injection { $0.hamster = by(tag: Hamster.self, on: $1) as Animal }
```
Во всех 3 случаях мы создали экземпляр или экземпляры класса Animal и что-то с ними сделали. Но в первом случае мы получили экземпляр с использованием имени, во втором мы получи все зарегестрированные в приложении классы которые использует в качестве сервиса тип `Animal` с любым видом модификаторов, в третьем мы получаем по типу и тегу.

Если посмотреть то синтаксис получается достаточно понятным, несмотря на его излишества. Те кто используют библиотеку давно скажут, что раньше такого небыло, но эта версия была направлена на то чтобы библиотека могла построить полный граф связей в голове, и данное решение было вынужденным. Единственный кто отличается - это внедрение с указанием имени. Но он и понятно - строка не может быть определена на этапе компиляции в отличии от типов. Именно по этой причине в внедрении через метод инициализации или обычный, отсутствует такая возможность - передавать массив имен отдельно будет выглядеть мягко говоря не красиво.

## Внедрение циклических зависимостей через свойства
Те кто пользуются библиотекой давно, или перешли на эту библиотеку с других, возможно возмутятся - зачем нам беспокоится о циклах! И будут правы - на самом деле программа может сама отследить циклы и разрешить их, но вопрос лишь в том сколько ей понадобится на это время. Старый способ разрешал зависимости достаточно изощренным способом, который работал, но приводил к проблемам если используется didSet у свойства. Дабы избежать подобных проблем, и повысить производительность, теперь наличие циклов надо указывать явно:
```Swift
class Cat {
  init(home: Home) { ... }
}
class Home {
  var animals: [Animal] = []
}

...
container.register(Cat.init)
  .lifetime(.objectGraph)
container.register(Home.init)
  .injection(cycle: true) { $0.animals.append($1 as Cat) }
  .lifetime(.objectGraph)
```

Но не думайте, что вас бросили и вам придеться лишний раз думать :) Библиотека позаботилась и функция `valid()` у контейнера, на самом деле сообщит вам и о том, что есть циклы которые надо разорвать.
Выше была написано что внедрение через свойства с указанием циклов работает чуточку иначе - эти свойства внедряются только после того как все остальные объекты будут инициализированы, так как мы не можем внедрить свойство которое ссылает на объект внутри инициализации которого мы находимся. То есть тем самым мы разрываем цикл.
Но и на этом дело не закончилось - раньше было время жизни `perDependency` которое является аналогом текущего `objectGraph`, но по умолчанию ставится `prototype`. Отличие этих времен жизни можно почитать в специальной главе, а тут лишь заострим внимание, на том, что любой объект который находится в цикле, и с которого может начинатся инициализация должен быть помечан не как `prototype`. На самом деле можно выучить более просто правило - все объекты в цикле стоит помечать не как `prototype`, и хотябы одно внедрение через свойство в цикле должно быть помечено.
Ситуации в которых стоит иметь `prototype` объекты в цикле настолько редки, что не будет описаны дабы не загромождать и так большую документацию лишней информацией. Скорей всего если у вас возникнет подобная ситуация, ваш уровень владения библиотекой будет настолько высок, что вы сможете это распознать сами.
В случае если у вас в цикле все объекты помечены как `prototype` библиотека выкинет ошибку при валидации, еслиже есть хотябы один не `prototype` и есть хотябы один `prototype`, то будет просто предупреждение.

На самом деле библиотека способна сама раставить правильно и время жизни, и найти точки разрыва, но вопрос лишь в целесообразности данных действий. Чтобы все это сделать требуется хороший анализ графа зависимостей, так как бывают циклы через 3, 4, 5 связей, а еще хуже если через одну переменную проходят по несколько циклов разной длины, и там могут быть еще циклы и т.д. Для автоматического решения всех проблем требуется затратить много времени, а так как DI работает на старте приложения, и это время очень ценное, то было принято решение - лучше сообщить один раз, чем выстраивать каждый раз.

#### [Главная](main.md)
#### [Предыдущая глава "Регистрация"](registration.md#Регистрация)
#### [Следующая глава "Валидация контейнера"](validation.md#Валидация-контейнера)
